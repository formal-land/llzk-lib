// RUN: zkir-opt -split-input-file %s 2>&1 | FileCheck %s

module attributes {veridise.lang = "zkir"} {
  /////////////////////////////////////////////////////////////////////////////////////////////
  // BEGIN: This section should be removed once implemented properly. It is tested elsewhere.
  // Pre-defined structs to import in all files generated by zirgen frontend
  module @risc0 {
    zkir.struct @ValU32 {
      field @low : !zkir.felt
      field @high : !zkir.felt

      func @compute(%low: !zkir.felt, %high: !zkir.felt) -> !zkir.struct<@risc0::@ValU32> {
        %self = new_struct : !zkir.struct<@risc0::@ValU32>
        writef %self[@low] = %low : !zkir.struct<@risc0::@ValU32>, !zkir.felt
        writef %self[@high] = %high : !zkir.struct<@risc0::@ValU32>, !zkir.felt
        return %self : !zkir.struct<@risc0::@ValU32>
      }

      func @constrain(%self: !zkir.struct<@risc0::@ValU32>, %low: !zkir.felt, %high: !zkir.felt) {
        return
      }
    }

    zkir.struct @Reg {
      // ZIR frontend should mark return value with `pub`
      field @reg : !zkir.felt {zkir.pub}

      func @compute(%v: !zkir.felt) -> !zkir.struct<@risc0::@Reg> {
        %self = new_struct : !zkir.struct<@risc0::@Reg>
        writef %self[@reg] = %v : !zkir.struct<@risc0::@Reg>, !zkir.felt
        return %self : !zkir.struct<@risc0::@Reg>
      }

      func @constrain(%self: !zkir.struct<@risc0::@Reg>, %v: !zkir.felt) {
        %0 = readf %self[@reg] : !zkir.struct<@risc0::@Reg>, !zkir.felt
        emit_eq %v, %0 : !zkir.felt
        return
      }
    }

    zkir.struct @Div {
      field @reciprocal : !zkir.felt
      // ZIR frontend should mark return value with `pub`
      field @synthetic_return : !zkir.felt {zkir.pub}

      func @compute(%lhs: !zkir.felt, %rhs: !zkir.felt) -> !zkir.struct<@risc0::@Div> {
        %self = new_struct : !zkir.struct<@risc0::@Div>
        // res_inv := inv(rhs);
        %res_inv = inv %rhs
        writef %self[@reciprocal] = %res_inv : !zkir.struct<@risc0::@Div>, !zkir.felt
        // self.synthetic_return := res_inv * lhs;
        %res_mul = mul %res_inv, %lhs
        writef %self[@synthetic_return] = %res_mul : !zkir.struct<@risc0::@Div>, !zkir.felt
        //
        return %self : !zkir.struct<@risc0::@Div>
      }

      func @constrain(%self: !zkir.struct<@risc0::@Div>, %lhs: !zkir.felt, %rhs: !zkir.felt) {
        // emit self.reciprocal * rhs = 1;
        %res_inv = readf %self[@reciprocal] : !zkir.struct<@risc0::@Div>, !zkir.felt
        %res_mul_1 = mul %res_inv, %rhs
        %const_1 = constfelt 1
        emit_eq %res_mul_1, %const_1 : !zkir.felt
        // emit self.synthetic_return = self.reciprocal * lhs;
        %res_self = readf %self[@synthetic_return] : !zkir.struct<@risc0::@Div>, !zkir.felt
        %res_mul_2 = mul %res_inv, %lhs
        emit_eq %res_self, %res_mul_2 : !zkir.felt
        //
        return
      }
    }
  }
  // END: This section should be removed once implemented properly. It is tested elsewhere.
  /////////////////////////////////////////////////////////////////////////////////////////////

  zkir.func private @LookupDelta(%table: !zkir.felt, %index: !zkir.felt, %count: !zkir.felt)

  // Since Zir functions can generate constraints but ZKIR functions cannot,
  //  the AssertBit function must be translated as a struct.
  zkir.struct @AssertBit {
    func @compute(%val: !zkir.felt) -> !zkir.struct<@AssertBit> {
      %self = new_struct : !zkir.struct<@AssertBit>
      return %self: !zkir.struct<@AssertBit>
    }

    func @constrain(%self: !zkir.struct<@AssertBit>, %val: !zkir.felt) {
      %const_1 = constfelt 1
      %t02 = sub %const_1, %val
      %t03 = mul %t02, %val
      %const_0 = constfelt 0
      emit_eq %t03, %const_0 : !zkir.felt
      return
    }
  }

  zkir.struct @NondetBitReg {
    field @ab: !zkir.struct<@AssertBit>
    field @reg: !zkir.felt
    // The `synthetic_return` is added here for clarity and a more strictly one-to-one
    // translation but it would also be valid to just put the `pub` modifier on `addr`.
    // ZIR frontend should mark return value with `pub`
    field @synthetic_return: !zkir.felt {zkir.pub}
    
    func @compute(%val: !zkir.felt) -> !zkir.struct<@NondetBitReg> {
      %self = new_struct : !zkir.struct<@NondetBitReg>
      writef %self[@reg] = %val : !zkir.struct<@NondetBitReg>, !zkir.felt
      %t02 = call @AssertBit::@compute(%val) : (!zkir.felt) -> (!zkir.struct<@AssertBit>)
      writef %self[@ab] = %t02 : !zkir.struct<@NondetBitReg>, !zkir.struct<@AssertBit>
      writef %self[@synthetic_return] = %val : !zkir.struct<@NondetBitReg>, !zkir.felt
      return %self: !zkir.struct<@NondetBitReg>
    }

    func @constrain(%self: !zkir.struct<@NondetBitReg>, %val: !zkir.felt) {
      %t02 = readf %self[@ab] : !zkir.struct<@NondetBitReg>, !zkir.struct<@AssertBit>
      %t03 = readf %self[@reg] : !zkir.struct<@NondetBitReg>, !zkir.felt
      call @AssertBit::@constrain(%t02, %t03) : (!zkir.struct<@AssertBit>, !zkir.felt) -> ()
      // Must always constrain the synthetic return value in case
      // it's used in a constraint by an outer component.
      %t04 = readf %self[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      emit_eq %t04, %t03 : !zkir.felt
      return
    }
  }

  zkir.struct @ArgU16 {
    field @count: !zkir.felt
    field @val: !zkir.felt
    
    func @compute(%count: !zkir.felt, %val: !zkir.felt) -> !zkir.struct<@ArgU16> {
      %self = new_struct : !zkir.struct<@ArgU16>
      writef %self[@count] = %count : !zkir.struct<@ArgU16>, !zkir.felt
      writef %self[@val] = %val : !zkir.struct<@ArgU16>, !zkir.felt
      %const_16 = constfelt 16
      call @LookupDelta(%const_16, %val, %count) : (!zkir.felt, !zkir.felt, !zkir.felt) -> ()
      return %self: !zkir.struct<@ArgU16>
    }

    func @constrain(%self: !zkir.struct<@ArgU16>, %count: !zkir.felt, %val: !zkir.felt) {
      return
    }
  }

  zkir.struct @NondetU16Reg {
    field @arg: !zkir.struct<@ArgU16>
    // ZIR frontend should mark return value with `pub`
    field @synthetic_return : !zkir.felt {zkir.pub}
    
    func @compute(%val: !zkir.felt) -> !zkir.struct<@NondetU16Reg> {
      %self = new_struct : !zkir.struct<@NondetU16Reg>
      %const_1 = constfelt 1
      %t02 = call @ArgU16::@compute(%const_1, %val) : (!zkir.felt, !zkir.felt) ->(!zkir.struct<@ArgU16>)
      writef %self[@arg] = %t02 : !zkir.struct<@NondetU16Reg>, !zkir.struct<@ArgU16>
      %t03 = readf %t02[@val] : !zkir.struct<@ArgU16>, !zkir.felt
      writef %self[@synthetic_return] = %t03 : !zkir.struct<@NondetU16Reg>, !zkir.felt
      return %self: !zkir.struct<@NondetU16Reg>
    }

    func @constrain(%self: !zkir.struct<@NondetU16Reg>, %val: !zkir.felt) {
      %const_1 = constfelt 1
      %t02 = readf %self[@arg] : !zkir.struct<@NondetU16Reg>, !zkir.struct<@ArgU16>
      call @ArgU16::@constrain(%t02, %const_1, %val) : (!zkir.struct<@ArgU16>, !zkir.felt, !zkir.felt) ->()
      %t03 = readf %t02[@count] : !zkir.struct<@ArgU16>, !zkir.felt
      emit_eq %const_1, %t03 : !zkir.felt
      // Must always constrain the synthetic return value in case
      // it's used in a constraint by an outer component.
      %t04 = readf %t02[@val] : !zkir.struct<@ArgU16>, !zkir.felt
      %t05 = readf %self[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      emit_eq %t05, %t04 : !zkir.felt
      return
    }
  }

  zkir.struct @U16Reg {
    field @ret: !zkir.struct<@NondetU16Reg>
    // ZIR frontend should mark return value with `pub`
    field @synthetic_return : !zkir.felt {zkir.pub}
    
    func @compute(%val: !zkir.felt) -> !zkir.struct<@U16Reg> {
      %self = new_struct : !zkir.struct<@U16Reg>
      %ret = call @NondetU16Reg::@compute(%val) : (!zkir.felt) -> (!zkir.struct<@NondetU16Reg>)
      writef %self[@ret] = %ret : !zkir.struct<@U16Reg>, !zkir.struct<@NondetU16Reg>
      writef %self[@synthetic_return] = %val : !zkir.struct<@U16Reg>, !zkir.felt
      return %self: !zkir.struct<@U16Reg>
    }

    func @constrain(%self: !zkir.struct<@U16Reg>, %val: !zkir.felt) {
      %ret = readf %self[@ret] : !zkir.struct<@U16Reg>, !zkir.struct<@NondetU16Reg>
      call @NondetU16Reg::@constrain(%ret, %val) : (!zkir.struct<@NondetU16Reg>, !zkir.felt) -> ()
      %t02 = readf %ret[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      emit_eq %t02, %val : !zkir.felt
      // Must always constrain the synthetic return value in case
      // it's used in a constraint by an outer component.
      %t03 = readf %self[@synthetic_return] : !zkir.struct<@U16Reg>, !zkir.felt
      emit_eq %t03, %val : !zkir.felt
      return
    }
  }

  zkir.struct @AddrDecomposeBits {
    field @low0: !zkir.struct<@NondetBitReg>
    field @low1: !zkir.struct<@NondetBitReg>
    field @low2: !zkir.felt
    field @upperDiff: !zkir.struct<@U16Reg>
    field @med14: !zkir.struct<@NondetU16Reg>
    field @addr: !zkir.felt
    // The `synthetic_return` is added here for clarity and a more strictly one-to-one
    // translation but it would also be valid to just put the `pub` modifier on `addr`.
    // ZIR frontend should mark return value with `pub`
    field @synthetic_return: !zkir.felt {zkir.pub}

    func @compute(%x: !zkir.struct<@risc0::@ValU32>, %mode: !zkir.felt) -> !zkir.struct<@AddrDecomposeBits> {
      %self = new_struct : !zkir.struct<@AddrDecomposeBits>
      // low0 := NondetBitReg.compute(x.low & 0x1);
      %t01 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %const_0x1 = constfelt 0x1
      %t02 = and %t01, %const_0x1
      %low0 = call @NondetBitReg::@compute(%t02) : (!zkir.felt) -> !zkir.struct<@NondetBitReg>
      writef %self[@low0] = %low0 : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
      // low1 := NondetBitReg.compute((x.low & 0x2) / 2);
      %t03 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %const_0x2 = constfelt 0x2
      %t04 = and %t03, %const_0x2
      %const_2 = constfelt 2
      %t05 = div %t04, %const_2
      %low1 = call @NondetBitReg::@compute(%t05) : (!zkir.felt) -> !zkir.struct<@NondetBitReg>
      writef %self[@low1] = %low1 : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
      // low2 := low1.synthetic_return * 2 + low0.synthetic_return;
      %t06 = readf %low1[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      %t07 = mul %t06, %const_2
      %t08 = readf %low0[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      %low2 = add %t07, %t08
      writef %self[@low2] = %low2 : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      // upperDiff := U16Reg.compute(mode * 0xffff + (1 - mode) * 0xbfff - x.high);
      %const_0xffff = constfelt 0xffff
      %t09 = mul %mode, %const_0xffff   // mode * 0xffff
      %const_1 = constfelt 1
      %t10 = sub %const_1, %mode        // (1 - mode)
      %const_0xbfff = constfelt 0xbfff
      %t11 = mul %t10, %const_0xbfff    // (1 - mode) * 0xbfff
      %t12 = add %t11, %t09             // mode * 0xffff + (1 - mode) * 0xbfff
      %t13 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t14 = sub %t12, %t13             // mode * 0xffff + (1 - mode) * 0xbfff - x.high
      %upperDiff = call @U16Reg::@compute(%t14) : (!zkir.felt) -> !zkir.struct<@U16Reg>
      writef %self[@upperDiff] = %upperDiff : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@U16Reg>
      // med14 := NondetU16Reg.compute((x.low - low2) / 4);
      %t15 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t16 = sub %t15, %low2            // (x.low - low2)
      %const_4 = constfelt 4
      %t17 = div %t16, %const_4         // (x.low - low2) / 4
      %med14 = call @NondetU16Reg::@compute(%t17) : (!zkir.felt) -> !zkir.struct<@NondetU16Reg>
      writef %self[@med14] = %med14 : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetU16Reg>
      // addr := 0x4000 * x.high + med14.synthetic_return;
      %const_0x4000 = constfelt 0x4000
      %t18 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t19 = mul %const_0x4000, %t18    // 0x4000 * x.high
      %t20 = readf %med14[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      %addr = add %t19, %t20            // 0x4000 * x.high + med14.synthetic_return
      writef %self[@addr] = %addr : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      // synthetic_return := addr;
      writef %self[@synthetic_return] = %addr : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      //
      return %self: !zkir.struct<@AddrDecomposeBits>
    }

    func @constrain(%self: !zkir.struct<@AddrDecomposeBits>, %x: !zkir.struct<@risc0::@ValU32>, %mode: !zkir.felt) {
      // low0.constrain(nondetFelt());
      %t01 = zkir.nondetfelt
      %low0 = readf %self[@low0] : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
      call @NondetBitReg::@constrain(%low0, %t01) : (!zkir.struct<@NondetBitReg>, !zkir.felt) -> ()
      // low1.constrain(nondetFelt());
      %t03 = zkir.nondetfelt
      %low1 = readf %self[@low1] : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
      call @NondetBitReg::@constrain(%low1, %t03) : (!zkir.struct<@NondetBitReg>, !zkir.felt) -> ()
      // emit low2 = low1.synthetic_return * 2 + low0.synthetic_return;
      %t05 = readf %self[@low2] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %t06 = readf %low1[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      %const_2 = constfelt 2
      %t07 = mul %t06, %const_2         // low1.synthetic_return * 2
      %t08 = readf %low0[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      %t04 = add %t07, %t08             // low1.synthetic_return * 2 + low0.synthetic_return
      emit_eq %t05, %t04 : !zkir.felt
      // upperDiff.constrain(mode * 0xffff + (1 - mode) * 0xbfff - x.high);
      %const_0xffff = constfelt 0xffff
      %t09 = mul %mode, %const_0xffff   // mode * 0xffff
      %const_1 = constfelt 1
      %t10 = sub %const_1, %mode        // (1 - mode)
      %const_0xbfff = constfelt 0xbfff
      %t11 = mul %t10, %const_0xbfff    // (1 - mode) * 0xbfff
      %t12 = add %t11, %t09             // mode * 0xffff + (1 - mode) * 0xbfff
      %t13 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t14 = sub %t12, %t13             // mode * 0xffff + (1 - mode) * 0xbfff - x.high
      %upperDiff = readf %self[@upperDiff] : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@U16Reg>
      call @U16Reg::@constrain(%upperDiff, %t14) : (!zkir.struct<@U16Reg>, !zkir.felt) -> ()
      // med14.constrain((x.low - low2) / 4);
      %t15 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t18 = readf %self[@low2] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %t16 = sub %t15, %t18             // (x.low - low2)
      %const_4 = constfelt 4
      %t17 = div %t16, %const_4         // (x.low - low2) / 4
      %med14 = readf %self[@med14] : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetU16Reg>
      call @NondetU16Reg::@constrain(%med14, %t17) : (!zkir.struct<@NondetU16Reg>, !zkir.felt) -> ()
      // emit med14.synthetic_return * 4 + low2 = x.low;
      %t19 = readf %med14[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      %t20 = mul %t19, %const_4         // med14.synthetic_return * 4
      %t21 = readf %self[@low2] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %t22 = add %t20, %t21             // med14.synthetic_return * 4 + low2
      %t23 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      emit_eq %t22, %t23 : !zkir.felt
      // emit addr = 0x4000 * x.high + med14.synthetic_return;
      %t24 = readf %self[@addr] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %const_0x4000 = constfelt 0x4000
      %t25 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t26 = mul %const_0x4000, %t25    // 0x4000 * x.high
      %t27 = readf %med14[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      %t28 = add %t26, %t27             // 0x4000 * x.high + med14.synthetic_return
      emit_eq %t24, %t28 : !zkir.felt
      // Must always constrain the synthetic return value in case
      // it's used in a constraint by an outer component.
      // emit synthetic_return = addr;
      %t30 = readf %self[@synthetic_return] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %t31 = readf %self[@addr] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      emit_eq %t30, %t31 : !zkir.felt
      return
    }
  }
}

//CHECK-LABEL: module attributes {veridise.lang = "zkir"} {
//CHECK-NEXT:    module @risc0 {
//CHECK-NEXT:      zkir.struct @ValU32 {
//CHECK-NEXT:        field @low : !zkir.felt
//CHECK-NEXT:        field @high : !zkir.felt
//CHECK-NEXT:        func @compute(%arg0: !zkir.felt, %arg1: !zkir.felt) -> !zkir.struct<@risc0::@ValU32> {
//CHECK-NEXT:          %self = new_struct : <@risc0::@ValU32>
//CHECK-NEXT:          writef %self[@low] = %arg0 : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:          writef %self[@high] = %arg1 : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:          return %self : !zkir.struct<@risc0::@ValU32>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%arg0: !zkir.struct<@risc0::@ValU32>, %arg1: !zkir.felt, %arg2: !zkir.felt) {
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:      zkir.struct @Reg {
//CHECK-NEXT:        field @reg : !zkir.felt {zkir.pub}
//CHECK-NEXT:        func @compute(%arg0: !zkir.felt) -> !zkir.struct<@risc0::@Reg> {
//CHECK-NEXT:          %self = new_struct : <@risc0::@Reg>
//CHECK-NEXT:          writef %self[@reg] = %arg0 : <@risc0::@Reg>, !zkir.felt
//CHECK-NEXT:          return %self : !zkir.struct<@risc0::@Reg>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%arg0: !zkir.struct<@risc0::@Reg>, %arg1: !zkir.felt) {
//CHECK-NEXT:          %0 = readf %arg0[@reg] : <@risc0::@Reg>, !zkir.felt
//CHECK-NEXT:          emit_eq %arg1, %0 : !zkir.felt
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:      zkir.struct @Div {
//CHECK-NEXT:        field @reciprocal : !zkir.felt
//CHECK-NEXT:        field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:        func @compute(%arg0: !zkir.felt, %arg1: !zkir.felt) -> !zkir.struct<@risc0::@Div> {
//CHECK-NEXT:          %self = new_struct : <@risc0::@Div>
//CHECK-NEXT:          %0 = inv %arg1
//CHECK-NEXT:          writef %self[@reciprocal] = %0 : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          %1 = mul %0, %arg0
//CHECK-NEXT:          writef %self[@synthetic_return] = %1 : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          return %self : !zkir.struct<@risc0::@Div>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%arg0: !zkir.struct<@risc0::@Div>, %arg1: !zkir.felt, %arg2: !zkir.felt) {
//CHECK-NEXT:          %0 = readf %arg0[@reciprocal] : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          %1 = mul %0, %arg2
//CHECK-NEXT:          %felt_const_1 = constfelt  1
//CHECK-NEXT:          emit_eq %1, %felt_const_1 : !zkir.felt
//CHECK-NEXT:          %2 = readf %arg0[@synthetic_return] : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          %3 = mul %0, %arg1
//CHECK-NEXT:          emit_eq %2, %3 : !zkir.felt
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.func private @LookupDelta(!zkir.felt, !zkir.felt, !zkir.felt)
//CHECK-NEXT:    zkir.struct @AssertBit {
//CHECK-NEXT:      func @compute(%arg0: !zkir.felt) -> !zkir.struct<@AssertBit> {
//CHECK-NEXT:        %self = new_struct : <@AssertBit>
//CHECK-NEXT:        return %self : !zkir.struct<@AssertBit>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%arg0: !zkir.struct<@AssertBit>, %arg1: !zkir.felt) {
//CHECK-NEXT:        %felt_const_1 = constfelt  1
//CHECK-NEXT:        %0 = sub %felt_const_1, %arg1
//CHECK-NEXT:        %1 = mul %0, %arg1
//CHECK-NEXT:        %felt_const_0 = constfelt  0
//CHECK-NEXT:        emit_eq %1, %felt_const_0 : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @NondetBitReg {
//CHECK-NEXT:      field @ab : !zkir.struct<@AssertBit>
//CHECK-NEXT:      field @reg : !zkir.felt
//CHECK-NEXT:      field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:      func @compute(%arg0: !zkir.felt) -> !zkir.struct<@NondetBitReg> {
//CHECK-NEXT:        %self = new_struct : <@NondetBitReg>
//CHECK-NEXT:        writef %self[@reg] = %arg0 : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %0 = call @AssertBit::@compute(%arg0) : (!zkir.felt) -> !zkir.struct<@AssertBit>
//CHECK-NEXT:        writef %self[@ab] = %0 : <@NondetBitReg>, !zkir.struct<@AssertBit>
//CHECK-NEXT:        writef %self[@synthetic_return] = %arg0 : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        return %self : !zkir.struct<@NondetBitReg>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%arg0: !zkir.struct<@NondetBitReg>, %arg1: !zkir.felt) {
//CHECK-NEXT:        %0 = readf %arg0[@ab] : <@NondetBitReg>, !zkir.struct<@AssertBit>
//CHECK-NEXT:        %1 = readf %arg0[@reg] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        call @AssertBit::@constrain(%0, %1) : (!zkir.struct<@AssertBit>, !zkir.felt) -> ()
//CHECK-NEXT:        %2 = readf %arg0[@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        emit_eq %2, %1 : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @ArgU16 {
//CHECK-NEXT:      field @count : !zkir.felt
//CHECK-NEXT:      field @val : !zkir.felt
//CHECK-NEXT:      func @compute(%arg0: !zkir.felt, %arg1: !zkir.felt) -> !zkir.struct<@ArgU16> {
//CHECK-NEXT:        %self = new_struct : <@ArgU16>
//CHECK-NEXT:        writef %self[@count] = %arg0 : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        writef %self[@val] = %arg1 : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        %felt_const_16 = constfelt  16
//CHECK-NEXT:        call @LookupDelta(%felt_const_16, %arg1, %arg0) : (!zkir.felt, !zkir.felt, !zkir.felt) -> ()
//CHECK-NEXT:        return %self : !zkir.struct<@ArgU16>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%arg0: !zkir.struct<@ArgU16>, %arg1: !zkir.felt, %arg2: !zkir.felt) {
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @NondetU16Reg {
//CHECK-NEXT:      field @arg : !zkir.struct<@ArgU16>
//CHECK-NEXT:      field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:      func @compute(%arg0: !zkir.felt) -> !zkir.struct<@NondetU16Reg> {
//CHECK-NEXT:        %self = new_struct : <@NondetU16Reg>
//CHECK-NEXT:        %felt_const_1 = constfelt  1
//CHECK-NEXT:        %0 = call @ArgU16::@compute(%felt_const_1, %arg0) : (!zkir.felt, !zkir.felt) -> !zkir.struct<@ArgU16>
//CHECK-NEXT:        writef %self[@arg] = %0 : <@NondetU16Reg>, !zkir.struct<@ArgU16>
//CHECK-NEXT:        %1 = readf %0[@val] : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        writef %self[@synthetic_return] = %1 : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        return %self : !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%arg0: !zkir.struct<@NondetU16Reg>, %arg1: !zkir.felt) {
//CHECK-NEXT:        %felt_const_1 = constfelt  1
//CHECK-NEXT:        %0 = readf %arg0[@arg] : <@NondetU16Reg>, !zkir.struct<@ArgU16>
//CHECK-NEXT:        call @ArgU16::@constrain(%0, %felt_const_1, %arg1) : (!zkir.struct<@ArgU16>, !zkir.felt, !zkir.felt) -> ()
//CHECK-NEXT:        %1 = readf %0[@count] : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        emit_eq %felt_const_1, %1 : !zkir.felt
//CHECK-NEXT:        %2 = readf %0[@val] : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        %3 = readf %arg0[@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        emit_eq %3, %2 : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @U16Reg {
//CHECK-NEXT:      field @ret : !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:      field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:      func @compute(%arg0: !zkir.felt) -> !zkir.struct<@U16Reg> {
//CHECK-NEXT:        %self = new_struct : <@U16Reg>
//CHECK-NEXT:        %0 = call @NondetU16Reg::@compute(%arg0) : (!zkir.felt) -> !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        writef %self[@ret] = %0 : <@U16Reg>, !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        writef %self[@synthetic_return] = %arg0 : <@U16Reg>, !zkir.felt
//CHECK-NEXT:        return %self : !zkir.struct<@U16Reg>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%arg0: !zkir.struct<@U16Reg>, %arg1: !zkir.felt) {
//CHECK-NEXT:        %0 = readf %arg0[@ret] : <@U16Reg>, !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        call @NondetU16Reg::@constrain(%0, %arg1) : (!zkir.struct<@NondetU16Reg>, !zkir.felt) -> ()
//CHECK-NEXT:        %1 = readf %0[@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        emit_eq %1, %arg1 : !zkir.felt
//CHECK-NEXT:        %2 = readf %arg0[@synthetic_return] : <@U16Reg>, !zkir.felt
//CHECK-NEXT:        emit_eq %2, %arg1 : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @AddrDecomposeBits {
//CHECK-NEXT:      field @low0 : !zkir.struct<@NondetBitReg>
//CHECK-NEXT:      field @low1 : !zkir.struct<@NondetBitReg>
//CHECK-NEXT:      field @low2 : !zkir.felt
//CHECK-NEXT:      field @upperDiff : !zkir.struct<@U16Reg>
//CHECK-NEXT:      field @med14 : !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:      field @addr : !zkir.felt
//CHECK-NEXT:      field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:      func @compute(%arg0: !zkir.struct<@risc0::@ValU32>, %arg1: !zkir.felt) -> !zkir.struct<@AddrDecomposeBits> {
//CHECK-NEXT:        %self = new_struct : <@AddrDecomposeBits>
//CHECK-NEXT:        %0 = readf %arg0[@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %felt_const_1 = constfelt  1
//CHECK-NEXT:        %1 = and %0, %felt_const_1
//CHECK-NEXT:        %2 = call @NondetBitReg::@compute(%1) : (!zkir.felt) -> !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        writef %self[@low0] = %2 : <@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        %3 = readf %arg0[@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %felt_const_2 = constfelt  2
//CHECK-NEXT:        %4 = and %3, %felt_const_2
//CHECK-NEXT:        %felt_const_2_0 = constfelt  2
//CHECK-NEXT:        %5 = div %4, %felt_const_2_0
//CHECK-NEXT:        %6 = call @NondetBitReg::@compute(%5) : (!zkir.felt) -> !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        writef %self[@low1] = %6 : <@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        %7 = readf %6[@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %8 = mul %7, %felt_const_2_0
//CHECK-NEXT:        %9 = readf %2[@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %10 = add %8, %9
//CHECK-NEXT:        writef %self[@low2] = %10 : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %felt_const_65535 = constfelt  65535
//CHECK-NEXT:        %11 = mul %arg1, %felt_const_65535
//CHECK-NEXT:        %felt_const_1_1 = constfelt  1
//CHECK-NEXT:        %12 = sub %felt_const_1_1, %arg1
//CHECK-NEXT:        %felt_const_49151 = constfelt  49151
//CHECK-NEXT:        %13 = mul %12, %felt_const_49151
//CHECK-NEXT:        %14 = add %13, %11
//CHECK-NEXT:        %15 = readf %arg0[@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %16 = sub %14, %15
//CHECK-NEXT:        %17 = call @U16Reg::@compute(%16) : (!zkir.felt) -> !zkir.struct<@U16Reg>
//CHECK-NEXT:        writef %self[@upperDiff] = %17 : <@AddrDecomposeBits>, !zkir.struct<@U16Reg>
//CHECK-NEXT:        %18 = readf %arg0[@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %19 = sub %18, %10
//CHECK-NEXT:        %felt_const_4 = constfelt  4
//CHECK-NEXT:        %20 = div %19, %felt_const_4
//CHECK-NEXT:        %21 = call @NondetU16Reg::@compute(%20) : (!zkir.felt) -> !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        writef %self[@med14] = %21 : <@AddrDecomposeBits>, !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        %felt_const_16384 = constfelt  16384
//CHECK-NEXT:        %22 = readf %arg0[@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %23 = mul %felt_const_16384, %22
//CHECK-NEXT:        %24 = readf %21[@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        %25 = add %23, %24
//CHECK-NEXT:        writef %self[@addr] = %25 : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        writef %self[@synthetic_return] = %25 : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        return %self : !zkir.struct<@AddrDecomposeBits>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%arg0: !zkir.struct<@AddrDecomposeBits>, %arg1: !zkir.struct<@risc0::@ValU32>, %arg2: !zkir.felt) {
//CHECK-NEXT:        %felt_nondet = nondetfelt
//CHECK-NEXT:        %0 = readf %arg0[@low0] : <@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        call @NondetBitReg::@constrain(%0, %felt_nondet) : (!zkir.struct<@NondetBitReg>, !zkir.felt) -> ()
//CHECK-NEXT:        %felt_nondet_0 = nondetfelt
//CHECK-NEXT:        %1 = readf %arg0[@low1] : <@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        call @NondetBitReg::@constrain(%1, %felt_nondet_0) : (!zkir.struct<@NondetBitReg>, !zkir.felt) -> ()
//CHECK-NEXT:        %2 = readf %arg0[@low2] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %3 = readf %1[@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %felt_const_2 = constfelt  2
//CHECK-NEXT:        %4 = mul %3, %felt_const_2
//CHECK-NEXT:        %5 = readf %0[@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %6 = add %4, %5
//CHECK-NEXT:        emit_eq %2, %6 : !zkir.felt
//CHECK-NEXT:        %felt_const_65535 = constfelt  65535
//CHECK-NEXT:        %7 = mul %arg2, %felt_const_65535
//CHECK-NEXT:        %felt_const_1 = constfelt  1
//CHECK-NEXT:        %8 = sub %felt_const_1, %arg2
//CHECK-NEXT:        %felt_const_49151 = constfelt  49151
//CHECK-NEXT:        %9 = mul %8, %felt_const_49151
//CHECK-NEXT:        %10 = add %9, %7
//CHECK-NEXT:        %11 = readf %arg1[@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %12 = sub %10, %11
//CHECK-NEXT:        %13 = readf %arg0[@upperDiff] : <@AddrDecomposeBits>, !zkir.struct<@U16Reg>
//CHECK-NEXT:        call @U16Reg::@constrain(%13, %12) : (!zkir.struct<@U16Reg>, !zkir.felt) -> ()
//CHECK-NEXT:        %14 = readf %arg1[@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %15 = readf %arg0[@low2] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %16 = sub %14, %15
//CHECK-NEXT:        %felt_const_4 = constfelt  4
//CHECK-NEXT:        %17 = div %16, %felt_const_4
//CHECK-NEXT:        %18 = readf %arg0[@med14] : <@AddrDecomposeBits>, !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        call @NondetU16Reg::@constrain(%18, %17) : (!zkir.struct<@NondetU16Reg>, !zkir.felt) -> ()
//CHECK-NEXT:        %19 = readf %18[@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        %20 = mul %19, %felt_const_4
//CHECK-NEXT:        %21 = readf %arg0[@low2] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %22 = add %20, %21
//CHECK-NEXT:        %23 = readf %arg1[@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        emit_eq %22, %23 : !zkir.felt
//CHECK-NEXT:        %24 = readf %arg0[@addr] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %felt_const_16384 = constfelt  16384
//CHECK-NEXT:        %25 = readf %arg1[@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %26 = mul %felt_const_16384, %25
//CHECK-NEXT:        %27 = readf %18[@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        %28 = add %26, %27
//CHECK-NEXT:        emit_eq %24, %28 : !zkir.felt
//CHECK-NEXT:        %29 = readf %arg0[@synthetic_return] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %30 = readf %arg0[@addr] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        emit_eq %29, %30 : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }
