// RUN: llzk-opt -I %S -split-input-file -llzk-inline-includes -llzk-print-interval-analysis %s 2>&1 | FileCheck %s

module attributes {veridise.lang = "llzk"} {
  llzk.struct @ConstantConstraint {
    func @compute(%a: !llzk.felt) -> !llzk.struct<@ConstantConstraint> {
      %self = new_struct : !llzk.struct<@ConstantConstraint>
      return %self : !llzk.struct<@ConstantConstraint>
    }

    func @constrain(%self: !llzk.struct<@ConstantConstraint>, %const: !llzk.felt) {
      %a = constfelt 1
      %b = constfelt 2
      %c = add %a, %b
      emit_eq %const, %c : !llzk.felt
      return
    }
  }
}

// CHECK-LABEL: @ConstantConstraint StructIntervals {
// CHECK-NEXT:     %arg1 in Degenerate(3)
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @CmpConstraint {
    func @compute(%a: !llzk.felt, %b: !llzk.felt) -> !llzk.struct<@CmpConstraint> {
      %self = new_struct : !llzk.struct<@CmpConstraint>
      return %self : !llzk.struct<@CmpConstraint>
    }

    func @constrain(%self: !llzk.struct<@CmpConstraint>, %a: !llzk.felt, %b: !llzk.felt) {
      %x = constfelt 1
      %y = constfelt 2
      %cmpA = cmp gt(%a, %x)
      assert %cmpA
      %cmpB = cmp le(%b, %y)
      assert %cmpB
      return
    }
  }
}

// CHECK-LABEL: @CmpConstraint StructIntervals {
// CHECK-NEXT:     %arg1 in TypeC:[ 2, 14828463434349501588600065238342573214075126148185506315513679787312170007181 ]
// CHECK-NEXT:     %arg2 in TypeA:[ 0, 2 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @FieldRangeConstraint {

    llzk.field @foo : !llzk.felt
    llzk.field @bar : !llzk.felt

    func @compute(%a: !llzk.felt, %b: !llzk.felt) -> !llzk.struct<@FieldRangeConstraint> {
      %self = new_struct : !llzk.struct<@FieldRangeConstraint>
      return %self : !llzk.struct<@FieldRangeConstraint>
    }

    func @constrain(%self: !llzk.struct<@FieldRangeConstraint>, %a: !llzk.felt, %b: !llzk.felt) {
      %x = constfelt 1
      %y = constfelt 2
      %cmpA = cmp gt(%a, %x)
      assert %cmpA
      %cmpB = cmp le(%b, %y)
      assert %cmpB
      %foo = readf %self[@foo] : !llzk.struct<@FieldRangeConstraint>, !llzk.felt
      emit_eq %foo, %x : !llzk.felt
      %bar = readf %self[@bar] : !llzk.struct<@FieldRangeConstraint>, !llzk.felt
      emit_eq %bar, %b : !llzk.felt
      return
    }
  }
}

// CHECK-LABEL: @FieldRangeConstraint StructIntervals {
// CHECK-NEXT:     %arg0[@foo] in Degenerate(1)
// CHECK-NEXT:     %arg0[@bar] in TypeA:[ 0, 2 ]
// CHECK-NEXT:     %arg1 in TypeC:[ 2, 14828463434349501588600065238342573214075126148185506315513679787312170007181 ]
// CHECK-NEXT:     %arg2 in TypeA:[ 0, 2 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @ArithConstraint {

    func @compute(%a: !llzk.felt, %b: !llzk.felt) -> !llzk.struct<@ArithConstraint> {
      %self = new_struct : !llzk.struct<@ArithConstraint>
      return %self : !llzk.struct<@ArithConstraint>
    }

    func @constrain(%self: !llzk.struct<@ArithConstraint>, %a: !llzk.felt, %b: !llzk.felt) {
      %5 = constfelt 5
      %7 = constfelt 7
      %11 = constfelt 11
      %cmp1 = cmp ge(%a, %5)
      assert %cmp1
      %cmp2 = cmp le(%a, %7)
      assert %cmp2
      %cmp3 = cmp gt(%b, %7)
      assert %cmp3
      %cmp4 = cmp le(%b, %11)
      assert %cmp4

      %mul = mul %a, %5
      %sub = sub %mul, %5
      %1 = div %11, %11
      %mod = mod %sub, %b
      %neg = neg %mod
      %final = add %mul, %neg

      %0 = constfelt 0
      %notzero = cmp ne(%final, %0)
      assert %notzero

      return
    }
  }
}

// CHECK-LABEL: @ArithConstraint StructIntervals {
// CHECK-NEXT:     %arg1 in TypeA:[ 5, 7 ]
// CHECK-NEXT:     %arg2 in TypeA:[ 8, 11 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @ArrayConstraint {

    llzk.field @arr : !llzk.array<3 x !llzk.felt>

    func @compute() -> !llzk.struct<@ArrayConstraint> {
      %self = new_struct : !llzk.struct<@ArrayConstraint>
      return %self : !llzk.struct<@ArrayConstraint>
    }

    func @constrain(%self: !llzk.struct<@ArrayConstraint>) {
      %5 = constfelt 5
      %7 = constfelt 7
      %11 = constfelt 11
      %arr = readf %self[@arr] : !llzk.struct<@ArrayConstraint>, !llzk.array<3 x !llzk.felt>
      %i0 = arith.constant 0 : index
      %i1 = arith.constant 1 : index
      %i2 = arith.constant 2 : index
      %a = readarr %arr[%i0] : !llzk.array<3 x !llzk.felt>, !llzk.felt
      %b = readarr %arr[%i1] : !llzk.array<3 x !llzk.felt>, !llzk.felt
      %c = readarr %arr[%i2] : !llzk.array<3 x !llzk.felt>, !llzk.felt
      %cmp1 = cmp ge(%a, %5)
      assert %cmp1
      %cmp2 = cmp le(%a, %7)
      assert %cmp2
      %cmp3 = cmp ge(%b, %7)
      assert %cmp3
      %cmp4 = cmp le(%b, %11)
      assert %cmp4

      emit_eq %c, %a : !llzk.felt

      return
    }
  }
}

// CHECK-LABEL: @ArrayConstraint StructIntervals {
// CHECK-NEXT:     %arg0[@arr][0] in TypeA:[ 5, 7 ]
// CHECK-NEXT:     %arg0[@arr][1] in TypeA:[ 7, 11 ]
// CHECK-NEXT:     %arg0[@arr][2] in TypeA:[ 5, 7 ]
// CHECK-NEXT: }