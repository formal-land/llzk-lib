// RUN: llzk-opt %s

#map = affine_map<()[s0] -> (s0)>
module attributes {veridise.lang = "llzk"} {
  module @globals {
  }
  struct.def @Component<[]> {
    function.def @compute() -> !struct.type<@Component<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Component<[]>>
      function.return %self : !struct.type<@Component<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Component<[]>>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @NondetReg<[]> {
    struct.field @"$super" : !felt.type
    struct.field @reg : !felt.type {column}
    function.def @compute(%arg0: !felt.type) -> !struct.type<@NondetReg<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@NondetReg<[]>>
      struct.writef %self[@reg] = %arg0 : <@NondetReg<[]>>, !felt.type
      struct.writef %self[@"$super"] = %arg0 : <@NondetReg<[]>>, !felt.type
      function.return %self : !struct.type<@NondetReg<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@NondetReg<[]>>, %arg1: !felt.type) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @NondetExtReg<[]> {
    struct.field @"$super" : !array.type<4 x !felt.type>
    struct.field @reg : !array.type<4 x !felt.type> {column}
    function.def @compute(%arg0: !array.type<4 x !felt.type>) -> !struct.type<@NondetExtReg<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@NondetExtReg<[]>>
      struct.writef %self[@reg] = %arg0 : <@NondetExtReg<[]>>, !array.type<4 x !felt.type>
      struct.writef %self[@"$super"] = %arg0 : <@NondetExtReg<[]>>, !array.type<4 x !felt.type>
      function.return %self : !struct.type<@NondetExtReg<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@NondetExtReg<[]>>, %arg1: !array.type<4 x !felt.type>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @EqzExt<[]> {
    struct.field @"$super" : !struct.type<@Component<[]>>
    function.def @compute(%arg0: !array.type<4 x !felt.type>) -> !struct.type<@EqzExt<[]>> attributes {function.allow_witness} {
      %felt_const_0 = felt.const 0
      %c3 = arith.constant 3 : index
      %c2 = arith.constant 2 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %self = struct.new : !struct.type<@EqzExt<[]>>
      %0 = array.read %arg0[%c0] : <4 x !felt.type>, !felt.type
      %1 = array.read %arg0[%c1] : <4 x !felt.type>, !felt.type
      %2 = array.read %arg0[%c2] : <4 x !felt.type>, !felt.type
      %3 = array.read %arg0[%c3] : <4 x !felt.type>, !felt.type
      %4 = bool.cmp eq(%0, %felt_const_0)
      %5 = bool.cmp eq(%1, %felt_const_0)
      %6 = bool.cmp eq(%2, %felt_const_0)
      %7 = bool.cmp eq(%3, %felt_const_0)
      %8 = bool.and %4, %5 : i1, i1
      %9 = bool.and %8, %6 : i1, i1
      %10 = bool.and %9, %7 : i1, i1
      bool.assert %10, "failed assertion: extended field element is not equal to zero"
      %11 = function.call @Component::@compute() : () -> !struct.type<@Component<[]>>
      struct.writef %self[@"$super"] = %11 : <@EqzExt<[]>>, !struct.type<@Component<[]>>
      function.return %self : !struct.type<@EqzExt<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@EqzExt<[]>>, %arg1: !array.type<4 x !felt.type>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @Reg<[]> {
    struct.field @"$super" : !struct.type<@NondetReg<[]>>
    struct.field @reg : !struct.type<@NondetReg<[]>> {column}
    function.def @compute(%arg0: !felt.type) -> !struct.type<@Reg<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Reg<[]>>
      %0 = function.call @NondetReg::@compute(%arg0) : (!felt.type) -> !struct.type<@NondetReg<[]>>
      struct.writef %self[@reg] = %0 : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %1 = struct.readf %self[@reg] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %2 = struct.readf %1[@"$super"] : <@NondetReg<[]>>, !felt.type
      struct.writef %self[@"$super"] = %1 : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      function.return %self : !struct.type<@Reg<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Reg<[]>>, %arg1: !felt.type) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@reg] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      function.call @NondetReg::@constrain(%0, %arg1) : (!struct.type<@NondetReg<[]>>, !felt.type) -> ()
      %1 = struct.readf %0[@"$super"] : <@NondetReg<[]>>, !felt.type
      constrain.eq %arg1, %1 : !felt.type, !felt.type
      function.return
    }
  }
  struct.def @ExtReg<[]> {
    struct.field @"$super" : !struct.type<@NondetExtReg<[]>>
    struct.field @"$temp" : !struct.type<@EqzExt<[]>>
    struct.field @reg : !struct.type<@NondetExtReg<[]>> {column}
    function.def @compute(%arg0: !array.type<4 x !felt.type>) -> !struct.type<@ExtReg<[]>> attributes {function.allow_witness} {
      %c3 = arith.constant 3 : index
      %c2 = arith.constant 2 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %self = struct.new : !struct.type<@ExtReg<[]>>
      %0 = function.call @NondetExtReg::@compute(%arg0) : (!array.type<4 x !felt.type>) -> !struct.type<@NondetExtReg<[]>>
      struct.writef %self[@reg] = %0 : <@ExtReg<[]>>, !struct.type<@NondetExtReg<[]>>
      %1 = struct.readf %self[@reg] : <@ExtReg<[]>>, !struct.type<@NondetExtReg<[]>>
      %2 = struct.readf %1[@"$super"] : <@NondetExtReg<[]>>, !array.type<4 x !felt.type>
      %3 = array.read %2[%c0] : <4 x !felt.type>, !felt.type
      %4 = array.read %2[%c1] : <4 x !felt.type>, !felt.type
      %5 = array.read %2[%c2] : <4 x !felt.type>, !felt.type
      %6 = array.read %2[%c3] : <4 x !felt.type>, !felt.type
      %7 = array.read %arg0[%c0] : <4 x !felt.type>, !felt.type
      %8 = array.read %arg0[%c1] : <4 x !felt.type>, !felt.type
      %9 = array.read %arg0[%c2] : <4 x !felt.type>, !felt.type
      %10 = array.read %arg0[%c3] : <4 x !felt.type>, !felt.type
      %11 = felt.sub %3, %7 : !felt.type, !felt.type
      %12 = felt.sub %4, %8 : !felt.type, !felt.type
      %13 = felt.sub %5, %9 : !felt.type, !felt.type
      %14 = felt.sub %6, %10 : !felt.type, !felt.type
      %array = array.new %11, %12, %13, %14 : <4 x !felt.type>
      %15 = function.call @EqzExt::@compute(%array) : (!array.type<4 x !felt.type>) -> !struct.type<@EqzExt<[]>>
      struct.writef %self[@"$temp"] = %15 : <@ExtReg<[]>>, !struct.type<@EqzExt<[]>>
      %16 = struct.readf %self[@"$temp"] : <@ExtReg<[]>>, !struct.type<@EqzExt<[]>>
      struct.writef %self[@"$super"] = %1 : <@ExtReg<[]>>, !struct.type<@NondetExtReg<[]>>
      function.return %self : !struct.type<@ExtReg<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@ExtReg<[]>>, %arg1: !array.type<4 x !felt.type>) attributes {function.allow_constraint} {
      %c3 = arith.constant 3 : index
      %c2 = arith.constant 2 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %0 = struct.readf %arg0[@reg] : <@ExtReg<[]>>, !struct.type<@NondetExtReg<[]>>
      function.call @NondetExtReg::@constrain(%0, %arg1) : (!struct.type<@NondetExtReg<[]>>, !array.type<4 x !felt.type>) -> ()
      %1 = struct.readf %0[@"$super"] : <@NondetExtReg<[]>>, !array.type<4 x !felt.type>
      %2 = array.read %1[%c0] : <4 x !felt.type>, !felt.type
      %3 = array.read %1[%c1] : <4 x !felt.type>, !felt.type
      %4 = array.read %1[%c2] : <4 x !felt.type>, !felt.type
      %5 = array.read %1[%c3] : <4 x !felt.type>, !felt.type
      %6 = array.read %arg1[%c0] : <4 x !felt.type>, !felt.type
      %7 = array.read %arg1[%c1] : <4 x !felt.type>, !felt.type
      %8 = array.read %arg1[%c2] : <4 x !felt.type>, !felt.type
      %9 = array.read %arg1[%c3] : <4 x !felt.type>, !felt.type
      %10 = felt.sub %2, %6 : !felt.type, !felt.type
      %11 = felt.sub %3, %7 : !felt.type, !felt.type
      %12 = felt.sub %4, %8 : !felt.type, !felt.type
      %13 = felt.sub %5, %9 : !felt.type, !felt.type
      %array = array.new %10, %11, %12, %13 : <4 x !felt.type>
      %14 = struct.readf %arg0[@"$temp"] : <@ExtReg<[]>>, !struct.type<@EqzExt<[]>>
      function.call @EqzExt::@constrain(%14, %array) : (!struct.type<@EqzExt<[]>>, !array.type<4 x !felt.type>) -> ()
      function.return
    }
  }
  struct.def @Div<[]> {
    struct.field @"$super" : !felt.type
    struct.field @reciprocal : !felt.type
    function.def @compute(%arg0: !felt.type, %arg1: !felt.type) -> !struct.type<@Div<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Div<[]>>
      %0 = felt.inv %arg1 : !felt.type
      struct.writef %self[@reciprocal] = %0 : <@Div<[]>>, !felt.type
      %1 = struct.readf %self[@reciprocal] : <@Div<[]>>, !felt.type
      %2 = felt.mul %1, %arg0 : !felt.type, !felt.type
      struct.writef %self[@"$super"] = %2 : <@Div<[]>>, !felt.type
      function.return %self : !struct.type<@Div<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Div<[]>>, %arg1: !felt.type, %arg2: !felt.type) attributes {function.allow_constraint} {
      %felt_const_1 = felt.const 1
      %0 = struct.readf %arg0[@reciprocal] : <@Div<[]>>, !felt.type
      %1 = felt.mul %0, %arg2 : !felt.type, !felt.type
      constrain.eq %1, %felt_const_1 : !felt.type, !felt.type
      function.return
    }
  }
  function.def private @Log$$extern(!string.type, !array.type<? x !felt.type>) -> !struct.type<@Component<[]>> attributes {extern}
  struct.def @Log<[]> {
    struct.field @"$super" : !struct.type<@Component<[]>>
    function.def @compute(%arg0: !string.type, %arg1: !array.type<? x !felt.type>) -> !struct.type<@Log<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Log<[]>>
      %0 = function.call @Log$$extern(%arg0, %arg1) : (!string.type, !array.type<? x !felt.type>) -> !struct.type<@Component<[]>>
      struct.writef %self[@"$super"] = %0 : <@Log<[]>>, !struct.type<@Component<[]>>
      function.return %self : !struct.type<@Log<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Log<[]>>, %arg1: !string.type, %arg2: !array.type<? x !felt.type>) attributes {function.allow_constraint} {
      %0 = function.call @Log$$extern(%arg1, %arg2) : (!string.type, !array.type<? x !felt.type>) -> !struct.type<@Component<[]>>
      function.return
    }
  }
  function.def private @Abort$$extern() -> !struct.type<@Component<[]>> attributes {extern}
  struct.def @Abort<[]> {
    struct.field @"$super" : !struct.type<@Component<[]>>
    function.def @compute() -> !struct.type<@Abort<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Abort<[]>>
      %0 = function.call @Abort$$extern() : () -> !struct.type<@Component<[]>>
      struct.writef %self[@"$super"] = %0 : <@Abort<[]>>, !struct.type<@Component<[]>>
      function.return %self : !struct.type<@Abort<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Abort<[]>>) attributes {function.allow_constraint} {
      %0 = function.call @Abort$$extern() : () -> !struct.type<@Component<[]>>
      function.return
    }
  }
  function.def private @Assert$$extern(!felt.type, !string.type) -> !struct.type<@Component<[]>> attributes {extern}
  struct.def @Assert<[]> {
    struct.field @"$super" : !struct.type<@Component<[]>>
    function.def @compute(%arg0: !felt.type, %arg1: !string.type) -> !struct.type<@Assert<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Assert<[]>>
      %0 = function.call @Assert$$extern(%arg0, %arg1) : (!felt.type, !string.type) -> !struct.type<@Component<[]>>
      struct.writef %self[@"$super"] = %0 : <@Assert<[]>>, !struct.type<@Component<[]>>
      function.return %self : !struct.type<@Assert<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Assert<[]>>, %arg1: !felt.type, %arg2: !string.type) attributes {function.allow_constraint} {
      %0 = function.call @Assert$$extern(%arg1, %arg2) : (!felt.type, !string.type) -> !struct.type<@Component<[]>>
      function.return
    }
  }
  struct.def @AssertBit<[]> {
    struct.field @"$super" : !struct.type<@Component<[]>>
    struct.field @"$temp" : !struct.type<@Component<[]>>
    function.def @compute(%arg0: !felt.type) -> !struct.type<@AssertBit<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@AssertBit<[]>>
      %0 = function.call @Component::@compute() : () -> !struct.type<@Component<[]>>
      struct.writef %self[@"$temp"] = %0 : <@AssertBit<[]>>, !struct.type<@Component<[]>>
      %1 = struct.readf %self[@"$temp"] : <@AssertBit<[]>>, !struct.type<@Component<[]>>
      struct.writef %self[@"$super"] = %1 : <@AssertBit<[]>>, !struct.type<@Component<[]>>
      function.return %self : !struct.type<@AssertBit<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@AssertBit<[]>>, %arg1: !felt.type) attributes {function.allow_constraint} {
      %felt_const_0 = felt.const 0
      %felt_const_1 = felt.const 1
      %0 = felt.sub %felt_const_1, %arg1 : !felt.type, !felt.type
      %1 = felt.mul %arg1, %0 : !felt.type, !felt.type
      constrain.eq %1, %felt_const_0 : !felt.type, !felt.type
      %2 = struct.readf %arg0[@"$temp"] : <@AssertBit<[]>>, !struct.type<@Component<[]>>
      function.call @Component::@constrain(%2) : (!struct.type<@Component<[]>>) -> ()
      function.return
    }
  }
  struct.def @NondetBitReg<[]> {
    struct.field @"$super" : !struct.type<@NondetReg<[]>>
    struct.field @"$temp" : !struct.type<@AssertBit<[]>>
    struct.field @reg : !struct.type<@NondetReg<[]>> {column}
    function.def @compute(%arg0: !felt.type) -> !struct.type<@NondetBitReg<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@NondetBitReg<[]>>
      %0 = function.call @NondetReg::@compute(%arg0) : (!felt.type) -> !struct.type<@NondetReg<[]>>
      struct.writef %self[@reg] = %0 : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
      %1 = struct.readf %self[@reg] : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
      %2 = struct.readf %1[@"$super"] : <@NondetReg<[]>>, !felt.type
      %3 = function.call @AssertBit::@compute(%2) : (!felt.type) -> !struct.type<@AssertBit<[]>>
      struct.writef %self[@"$temp"] = %3 : <@NondetBitReg<[]>>, !struct.type<@AssertBit<[]>>
      %4 = struct.readf %self[@"$temp"] : <@NondetBitReg<[]>>, !struct.type<@AssertBit<[]>>
      struct.writef %self[@"$super"] = %1 : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
      function.return %self : !struct.type<@NondetBitReg<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@NondetBitReg<[]>>, %arg1: !felt.type) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@reg] : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
      function.call @NondetReg::@constrain(%0, %arg1) : (!struct.type<@NondetReg<[]>>, !felt.type) -> ()
      %1 = struct.readf %0[@"$super"] : <@NondetReg<[]>>, !felt.type
      %2 = struct.readf %arg0[@"$temp"] : <@NondetBitReg<[]>>, !struct.type<@AssertBit<[]>>
      function.call @AssertBit::@constrain(%2, %1) : (!struct.type<@AssertBit<[]>>, !felt.type) -> ()
      function.return
    }
  }
  struct.def @BitAnd<[]> {
    struct.field @"$super" : !felt.type
    function.def @compute(%arg0: !felt.type, %arg1: !felt.type) -> !struct.type<@BitAnd<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@BitAnd<[]>>
      %0 = felt.mul %arg0, %arg1 : !felt.type, !felt.type
      struct.writef %self[@"$super"] = %0 : <@BitAnd<[]>>, !felt.type
      function.return %self : !struct.type<@BitAnd<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@BitAnd<[]>>, %arg1: !felt.type, %arg2: !felt.type) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @OneHot<[@N]> {
    struct.field @"$super" : !array.type<#map x !struct.type<@NondetBitReg<[]>>>
    struct.field @"$temp_1" : !array.type<#map x !felt.type>
    struct.field @"$array" : !array.type<#map x !felt.type>
    struct.field @"$temp_0" : !array.type<#map x !felt.type>
    struct.field @"$temp" : !array.type<#map x !struct.type<@NondetBitReg<[]>>> {column}
    struct.field @bits : !array.type<#map x !struct.type<@NondetBitReg<[]>>> {column}
    function.def @compute(%arg0: !felt.type) -> !struct.type<@OneHot<[@N]>> attributes {function.allow_witness} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@OneHot<[@N]>>
      %0 = poly.read_const @N : !felt.type
      %1 = poly.read_const @N : index
      %array = array.new{()[%1]} : <#map x !felt.type>
      %2 = poly.read_const @N : index
      scf.for %arg1 = %c0 to %2 step %c1 {
        %14 = cast.tofelt %arg1 : index
        array.write %array[%arg1] = %14 : <#map x !felt.type>, !felt.type
      }
      %3 = poly.read_const @N : index
      %array_0 = array.new{()[%3]} : <#map x !struct.type<@NondetBitReg<[]>>>
      %4 = array.len %array, %c0 : <#map x !felt.type>
      scf.for %arg1 = %c0 to %4 step %c1 {
        %14 = array.read %array[%arg1] : <#map x !felt.type>, !felt.type
        %15 = felt.sub %14, %arg0 : !felt.type, !felt.type
        %16 = bool.cmp eq(%15, %felt_const_0)
        %17 = cast.tofelt %16 : i1
        %18 = function.call @NondetBitReg::@compute(%17) : (!felt.type) -> !struct.type<@NondetBitReg<[]>>
        %19 = struct.readf %self[@"$temp"] : <@OneHot<[@N]>>, !array.type<#map x !struct.type<@NondetBitReg<[]>>>
        array.write %19[%arg1] = %18 : <#map x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
        struct.writef %self[@"$temp"] = %19 : <@OneHot<[@N]>>, !array.type<#map x !struct.type<@NondetBitReg<[]>>>
        %20 = struct.readf %self[@"$temp"] : <@OneHot<[@N]>>, !array.type<#map x !struct.type<@NondetBitReg<[]>>>
        %21 = array.read %20[%arg1] : <#map x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
        array.write %array_0[%arg1] = %21 : <#map x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
      } {original_op = "map"}
      struct.writef %self[@bits] = %array_0 : <@OneHot<[@N]>>, !array.type<#map x !struct.type<@NondetBitReg<[]>>>
      %5 = struct.readf %self[@bits] : <@OneHot<[@N]>>, !array.type<#map x !struct.type<@NondetBitReg<[]>>>
      %6 = array.len %5, %c0 : <#map x !struct.type<@NondetBitReg<[]>>>
      %7 = scf.for %arg1 = %c0 to %6 step %c1 iter_args(%arg2 = %felt_const_0) -> (!felt.type) {
        %14 = array.read %5[%arg1] : <#map x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
        %15 = struct.readf %14[@"$super"] : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
        %16 = struct.readf %15[@"$super"] : <@NondetReg<[]>>, !felt.type
        %17 = felt.add %arg2, %16 : !felt.type, !felt.type
        %18 = struct.readf %self[@"$temp_0"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        array.write %18[%arg1] = %17 : <#map x !felt.type>, !felt.type
        struct.writef %self[@"$temp_0"] = %18 : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        %19 = struct.readf %self[@"$temp_0"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        %20 = array.read %19[%arg1] : <#map x !felt.type>, !felt.type
        scf.yield %20 : !felt.type
      } {original_op = "reduce"}
      %8 = poly.read_const @N : index
      %array_1 = array.new{()[%8]} : <#map x !felt.type>
      scf.for %arg1 = %c0 to %2 step %c1 {
        %14 = cast.tofelt %arg1 : index
        array.write %array_1[%arg1] = %14 : <#map x !felt.type>, !felt.type
      }
      %9 = poly.read_const @N : index
      %array_2 = array.new{()[%9]} : <#map x !felt.type>
      %10 = array.len %array_1, %c0 : <#map x !felt.type>
      scf.for %arg1 = %c0 to %10 step %c1 {
        %14 = array.read %array_1[%arg1] : <#map x !felt.type>, !felt.type
        %15 = cast.toindex %14
        %16 = array.read %5[%15] : <#map x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
        %17 = struct.readf %16[@"$super"] : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
        %18 = struct.readf %17[@"$super"] : <@NondetReg<[]>>, !felt.type
        %19 = felt.mul %18, %14 : !felt.type, !felt.type
        array.write %array_2[%arg1] = %19 : <#map x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_2 : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
      %11 = struct.readf %self[@"$array"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
      %12 = array.len %11, %c0 : <#map x !felt.type>
      %13 = scf.for %arg1 = %c0 to %12 step %c1 iter_args(%arg2 = %felt_const_0) -> (!felt.type) {
        %14 = array.read %11[%arg1] : <#map x !felt.type>, !felt.type
        %15 = felt.add %arg2, %14 : !felt.type, !felt.type
        %16 = struct.readf %self[@"$temp_1"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        array.write %16[%arg1] = %15 : <#map x !felt.type>, !felt.type
        struct.writef %self[@"$temp_1"] = %16 : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        %17 = struct.readf %self[@"$temp_1"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        %18 = array.read %17[%arg1] : <#map x !felt.type>, !felt.type
        scf.yield %18 : !felt.type
      } {original_op = "reduce"}
      struct.writef %self[@"$super"] = %5 : <@OneHot<[@N]>>, !array.type<#map x !struct.type<@NondetBitReg<[]>>>
      function.return %self : !struct.type<@OneHot<[@N]>>
    }
    function.def @constrain(%arg0: !struct.type<@OneHot<[@N]>>, %arg1: !felt.type) attributes {function.allow_constraint} {
      %felt_const_1 = felt.const 1
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_0 = felt.const 0
      %0 = poly.read_const @N : !felt.type
      %1 = poly.read_const @N : index
      %array = array.new{()[%1]} : <#map x !felt.type>
      %2 = poly.read_const @N : index
      scf.for %arg2 = %c0 to %2 step %c1 {
        %14 = cast.tofelt %arg2 : index
        array.write %array[%arg2] = %14 : <#map x !felt.type>, !felt.type
      }
      %3 = poly.read_const @N : index
      %array_0 = array.new{()[%3]} : <#map x !struct.type<@NondetBitReg<[]>>>
      %4 = array.len %array, %c0 : <#map x !felt.type>
      scf.for %arg2 = %c0 to %4 step %c1 {
        %14 = array.read %array[%arg2] : <#map x !felt.type>, !felt.type
        %15 = felt.sub %14, %arg1 : !felt.type, !felt.type
        %16 = bool.cmp eq(%15, %felt_const_0)
        %17 = cast.tofelt %16 : i1
        %18 = struct.readf %arg0[@"$temp"] : <@OneHot<[@N]>>, !array.type<#map x !struct.type<@NondetBitReg<[]>>>
        %19 = struct.readf %arg0[@"$temp"] : <@OneHot<[@N]>>, !array.type<#map x !struct.type<@NondetBitReg<[]>>>
        %20 = array.read %19[%arg2] : <#map x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
        function.call @NondetBitReg::@constrain(%20, %17) : (!struct.type<@NondetBitReg<[]>>, !felt.type) -> ()
        array.write %array_0[%arg2] = %20 : <#map x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
      } {original_op = "map"}
      %5 = struct.readf %arg0[@bits] : <@OneHot<[@N]>>, !array.type<#map x !struct.type<@NondetBitReg<[]>>>
      %6 = array.len %5, %c0 : <#map x !struct.type<@NondetBitReg<[]>>>
      %7 = scf.for %arg2 = %c0 to %6 step %c1 iter_args(%arg3 = %felt_const_0) -> (!felt.type) {
        %14 = array.read %5[%arg2] : <#map x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
        %15 = struct.readf %14[@"$super"] : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
        %16 = struct.readf %15[@"$super"] : <@NondetReg<[]>>, !felt.type
        %17 = struct.readf %arg0[@"$temp_0"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        %18 = struct.readf %arg0[@"$temp_0"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        %19 = array.read %18[%arg2] : <#map x !felt.type>, !felt.type
        scf.yield %19 : !felt.type
      } {original_op = "reduce"}
      constrain.eq %7, %felt_const_1 : !felt.type, !felt.type
      %8 = poly.read_const @N : index
      %array_1 = array.new{()[%8]} : <#map x !felt.type>
      scf.for %arg2 = %c0 to %2 step %c1 {
        %14 = cast.tofelt %arg2 : index
        array.write %array_1[%arg2] = %14 : <#map x !felt.type>, !felt.type
      }
      %9 = poly.read_const @N : index
      %array_2 = array.new{()[%9]} : <#map x !felt.type>
      %10 = array.len %array_1, %c0 : <#map x !felt.type>
      scf.for %arg2 = %c0 to %10 step %c1 {
        %14 = array.read %array_1[%arg2] : <#map x !felt.type>, !felt.type
        %15 = cast.toindex %14
        %16 = array.read %5[%15] : <#map x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
        %17 = struct.readf %16[@"$super"] : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
        %18 = struct.readf %17[@"$super"] : <@NondetReg<[]>>, !felt.type
        %19 = felt.mul %18, %14 : !felt.type, !felt.type
        array.write %array_2[%arg2] = %19 : <#map x !felt.type>, !felt.type
      } {original_op = "map"}
      %11 = struct.readf %arg0[@"$array"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
      %12 = array.len %11, %c0 : <#map x !felt.type>
      %13 = scf.for %arg2 = %c0 to %12 step %c1 iter_args(%arg3 = %felt_const_0) -> (!felt.type) {
        %14 = array.read %11[%arg2] : <#map x !felt.type>, !felt.type
        %15 = struct.readf %arg0[@"$temp_1"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        %16 = struct.readf %arg0[@"$temp_1"] : <@OneHot<[@N]>>, !array.type<#map x !felt.type>
        %17 = array.read %16[%arg2] : <#map x !felt.type>, !felt.type
        scf.yield %17 : !felt.type
      } {original_op = "reduce"}
      constrain.eq %13, %arg1 : !felt.type, !felt.type
      function.return
    }
  }
  struct.def @Switch<[@N, @idx]> {
    struct.field @"$super" : !array.type<#map x !felt.type>
    struct.field @"$array" : !array.type<#map x !felt.type>
    function.def @compute() -> !struct.type<@Switch<[@N, @idx]>> attributes {function.allow_witness} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@Switch<[@N, @idx]>>
      %0 = poly.read_const @N : !felt.type
      %1 = poly.read_const @idx : !felt.type
      %2 = poly.read_const @N : index
      %array = array.new{()[%2]} : <#map x !felt.type>
      %3 = poly.read_const @N : index
      scf.for %arg0 = %c0 to %3 step %c1 {
        %7 = cast.tofelt %arg0 : index
        array.write %array[%arg0] = %7 : <#map x !felt.type>, !felt.type
      }
      %4 = poly.read_const @N : index
      %array_0 = array.new{()[%4]} : <#map x !felt.type>
      %5 = array.len %array, %c0 : <#map x !felt.type>
      scf.for %arg0 = %c0 to %5 step %c1 {
        %7 = array.read %array[%arg0] : <#map x !felt.type>, !felt.type
        %8 = felt.sub %7, %1 : !felt.type, !felt.type
        %9 = bool.cmp eq(%8, %felt_const_0)
        %10 = cast.tofelt %9 : i1
        array.write %array_0[%arg0] = %10 : <#map x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_0 : <@Switch<[@N, @idx]>>, !array.type<#map x !felt.type>
      %6 = struct.readf %self[@"$array"] : <@Switch<[@N, @idx]>>, !array.type<#map x !felt.type>
      struct.writef %self[@"$super"] = %6 : <@Switch<[@N, @idx]>>, !array.type<#map x !felt.type>
      function.return %self : !struct.type<@Switch<[@N, @idx]>>
    }
    function.def @constrain(%arg0: !struct.type<@Switch<[@N, @idx]>>) attributes {function.allow_constraint} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_0 = felt.const 0
      %0 = poly.read_const @N : !felt.type
      %1 = poly.read_const @idx : !felt.type
      %2 = poly.read_const @N : index
      %array = array.new{()[%2]} : <#map x !felt.type>
      %3 = poly.read_const @N : index
      scf.for %arg1 = %c0 to %3 step %c1 {
        %7 = cast.tofelt %arg1 : index
        array.write %array[%arg1] = %7 : <#map x !felt.type>, !felt.type
      }
      %4 = poly.read_const @N : index
      %array_0 = array.new{()[%4]} : <#map x !felt.type>
      %5 = array.len %array, %c0 : <#map x !felt.type>
      scf.for %arg1 = %c0 to %5 step %c1 {
        %7 = array.read %array[%arg1] : <#map x !felt.type>, !felt.type
        %8 = felt.sub %7, %1 : !felt.type, !felt.type
        %9 = bool.cmp eq(%8, %felt_const_0)
        %10 = cast.tofelt %9 : i1
        array.write %array_0[%arg1] = %10 : <#map x !felt.type>, !felt.type
      } {original_op = "map"}
      %6 = struct.readf %arg0[@"$array"] : <@Switch<[@N, @idx]>>, !array.type<#map x !felt.type>
      function.return
    }
  }
  struct.def @M_INT_DIAG_HZN<[]> {
    struct.field @"$super" : !array.type<24 x !felt.type>
    function.def @compute() -> !struct.type<@M_INT_DIAG_HZN<[]>> attributes {function.allow_witness} {
      %felt_const_918610824 = felt.const 918610824
      %felt_const_13683276 = felt.const 13683276
      %felt_const_606789471 = felt.const 606789471
      %felt_const_1974912880 = felt.const 1974912880
      %felt_const_65998480 = felt.const 65998480
      %felt_const_1461037801 = felt.const 1461037801
      %felt_const_1997365680 = felt.const 1997365680
      %felt_const_801504236 = felt.const 801504236
      %felt_const_1792686146 = felt.const 1792686146
      %felt_const_1001081699 = felt.const 1001081699
      %felt_const_98371040 = felt.const 98371040
      %felt_const_1389833583 = felt.const 1389833583
      %felt_const_106789798 = felt.const 106789798
      %felt_const_1188752902 = felt.const 1188752902
      %felt_const_20525701 = felt.const 20525701
      %felt_const_1558116381 = felt.const 1558116381
      %felt_const_1942928017 = felt.const 1942928017
      %felt_const_1928969209 = felt.const 1928969209
      %felt_const_51866717 = felt.const 51866717
      %felt_const_658182609 = felt.const 658182609
      %felt_const_1867716110 = felt.const 1867716110
      %felt_const_111593398 = felt.const 111593398
      %felt_const_375892129 = felt.const 375892129
      %felt_const_1083257840 = felt.const 1083257840
      %self = struct.new : !struct.type<@M_INT_DIAG_HZN<[]>>
      %array = array.new %felt_const_1083257840, %felt_const_375892129, %felt_const_111593398, %felt_const_1867716110, %felt_const_658182609, %felt_const_51866717, %felt_const_1928969209, %felt_const_1942928017, %felt_const_1558116381, %felt_const_20525701, %felt_const_1188752902, %felt_const_106789798, %felt_const_1389833583, %felt_const_98371040, %felt_const_1001081699, %felt_const_1792686146, %felt_const_801504236, %felt_const_1997365680, %felt_const_1461037801, %felt_const_65998480, %felt_const_1974912880, %felt_const_606789471, %felt_const_13683276, %felt_const_918610824 : <24 x !felt.type>
      struct.writef %self[@"$super"] = %array : <@M_INT_DIAG_HZN<[]>>, !array.type<24 x !felt.type>
      function.return %self : !struct.type<@M_INT_DIAG_HZN<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@M_INT_DIAG_HZN<[]>>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @MultiplyByMInt<[]> {
    struct.field @"$super" : !array.type<24 x !felt.type>
    struct.field @"$temp_0" : !array.type<24 x !struct.type<@M_INT_DIAG_HZN<[]>>>
    struct.field @"$array" : !array.type<24 x !felt.type>
    struct.field @"$temp" : !array.type<24 x !felt.type>
    function.def @compute(%arg0: !array.type<24 x !felt.type>) -> !struct.type<@MultiplyByMInt<[]>> attributes {function.allow_witness} {
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@MultiplyByMInt<[]>>
      %0 = scf.for %arg1 = %c0 to %c24 step %c1 iter_args(%arg2 = %felt_const_0) -> (!felt.type) {
        %2 = array.read %arg0[%arg1] : <24 x !felt.type>, !felt.type
        %3 = felt.add %arg2, %2 : !felt.type, !felt.type
        %4 = struct.readf %self[@"$temp"] : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
        array.write %4[%arg1] = %3 : <24 x !felt.type>, !felt.type
        struct.writef %self[@"$temp"] = %4 : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
        %5 = struct.readf %self[@"$temp"] : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
        %6 = array.read %5[%arg1] : <24 x !felt.type>, !felt.type
        scf.yield %6 : !felt.type
      } {original_op = "reduce"}
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !felt.type>
      scf.for %arg1 = %c0 to %c24 step %c1 {
        %2 = array.read %array[%arg1] : <24 x !felt.type>, !felt.type
        %3 = function.call @M_INT_DIAG_HZN::@compute() : () -> !struct.type<@M_INT_DIAG_HZN<[]>>
        %4 = struct.readf %self[@"$temp_0"] : <@MultiplyByMInt<[]>>, !array.type<24 x !struct.type<@M_INT_DIAG_HZN<[]>>>
        array.write %4[%arg1] = %3 : <24 x !struct.type<@M_INT_DIAG_HZN<[]>>>, !struct.type<@M_INT_DIAG_HZN<[]>>
        struct.writef %self[@"$temp_0"] = %4 : <@MultiplyByMInt<[]>>, !array.type<24 x !struct.type<@M_INT_DIAG_HZN<[]>>>
        %5 = struct.readf %self[@"$temp_0"] : <@MultiplyByMInt<[]>>, !array.type<24 x !struct.type<@M_INT_DIAG_HZN<[]>>>
        %6 = array.read %5[%arg1] : <24 x !struct.type<@M_INT_DIAG_HZN<[]>>>, !struct.type<@M_INT_DIAG_HZN<[]>>
        %7 = struct.readf %6[@"$super"] : <@M_INT_DIAG_HZN<[]>>, !array.type<24 x !felt.type>
        %8 = cast.toindex %2
        %9 = array.read %7[%8] : <24 x !felt.type>, !felt.type
        %10 = cast.toindex %2
        %11 = array.read %arg0[%10] : <24 x !felt.type>, !felt.type
        %12 = felt.mul %9, %11 : !felt.type, !felt.type
        %13 = felt.add %0, %12 : !felt.type, !felt.type
        array.write %array_0[%arg1] = %13 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_0 : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
      %1 = struct.readf %self[@"$array"] : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
      struct.writef %self[@"$super"] = %1 : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
      function.return %self : !struct.type<@MultiplyByMInt<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@MultiplyByMInt<[]>>, %arg1: !array.type<24 x !felt.type>) attributes {function.allow_constraint} {
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %c24 = arith.constant 24 : index
      %0 = scf.for %arg2 = %c0 to %c24 step %c1 iter_args(%arg3 = %felt_const_0) -> (!felt.type) {
        %2 = array.read %arg1[%arg2] : <24 x !felt.type>, !felt.type
        %3 = struct.readf %arg0[@"$temp"] : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
        %4 = struct.readf %arg0[@"$temp"] : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
        %5 = array.read %4[%arg2] : <24 x !felt.type>, !felt.type
        scf.yield %5 : !felt.type
      } {original_op = "reduce"}
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !felt.type>
      scf.for %arg2 = %c0 to %c24 step %c1 {
        %2 = array.read %array[%arg2] : <24 x !felt.type>, !felt.type
        %3 = struct.readf %arg0[@"$temp_0"] : <@MultiplyByMInt<[]>>, !array.type<24 x !struct.type<@M_INT_DIAG_HZN<[]>>>
        %4 = struct.readf %arg0[@"$temp_0"] : <@MultiplyByMInt<[]>>, !array.type<24 x !struct.type<@M_INT_DIAG_HZN<[]>>>
        %5 = array.read %4[%arg2] : <24 x !struct.type<@M_INT_DIAG_HZN<[]>>>, !struct.type<@M_INT_DIAG_HZN<[]>>
        function.call @M_INT_DIAG_HZN::@constrain(%5) : (!struct.type<@M_INT_DIAG_HZN<[]>>) -> ()
        %6 = struct.readf %5[@"$super"] : <@M_INT_DIAG_HZN<[]>>, !array.type<24 x !felt.type>
        %7 = cast.toindex %2
        %8 = array.read %6[%7] : <24 x !felt.type>, !felt.type
        %9 = cast.toindex %2
        %10 = array.read %arg1[%9] : <24 x !felt.type>, !felt.type
        %11 = felt.mul %8, %10 : !felt.type, !felt.type
        %12 = felt.add %0, %11 : !felt.type, !felt.type
        array.write %array_0[%arg2] = %12 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      %1 = struct.readf %arg0[@"$array"] : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
      function.return
    }
  }
  struct.def @INT_ROUND_CONSTANTS<[]> {
    struct.field @"$super" : !array.type<21 x !felt.type>
    function.def @compute() -> !struct.type<@INT_ROUND_CONSTANTS<[]>> attributes {function.allow_witness} {
      %felt_const_1810596765 = felt.const 1810596765
      %felt_const_1210751726 = felt.const 1210751726
      %felt_const_1327682690 = felt.const 1327682690
      %felt_const_1886977120 = felt.const 1886977120
      %felt_const_1551596046 = felt.const 1551596046
      %felt_const_1186174623 = felt.const 1186174623
      %felt_const_1199068823 = felt.const 1199068823
      %felt_const_1240419708 = felt.const 1240419708
      %felt_const_1708681573 = felt.const 1708681573
      %felt_const_308575117 = felt.const 308575117
      %felt_const_1111544260 = felt.const 1111544260
      %felt_const_822033215 = felt.const 822033215
      %felt_const_1891545577 = felt.const 1891545577
      %felt_const_440300254 = felt.const 440300254
      %felt_const_1726563304 = felt.const 1726563304
      %felt_const_1365519753 = felt.const 1365519753
      %felt_const_924863639 = felt.const 924863639
      %felt_const_1540960371 = felt.const 1540960371
      %felt_const_1052077299 = felt.const 1052077299
      %felt_const_1930103076 = felt.const 1930103076
      %felt_const_497520322 = felt.const 497520322
      %self = struct.new : !struct.type<@INT_ROUND_CONSTANTS<[]>>
      %array = array.new %felt_const_497520322, %felt_const_1930103076, %felt_const_1052077299, %felt_const_1540960371, %felt_const_924863639, %felt_const_1365519753, %felt_const_1726563304, %felt_const_440300254, %felt_const_1891545577, %felt_const_822033215, %felt_const_1111544260, %felt_const_308575117, %felt_const_1708681573, %felt_const_1240419708, %felt_const_1199068823, %felt_const_1186174623, %felt_const_1551596046, %felt_const_1886977120, %felt_const_1327682690, %felt_const_1210751726, %felt_const_1810596765 : <21 x !felt.type>
      struct.writef %self[@"$super"] = %array : <@INT_ROUND_CONSTANTS<[]>>, !array.type<21 x !felt.type>
      function.return %self : !struct.type<@INT_ROUND_CONSTANTS<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@INT_ROUND_CONSTANTS<[]>>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @SBox<[]> {
    struct.field @"$super" : !struct.type<@Reg<[]>>
    struct.field @out : !struct.type<@Reg<[]>> {column}
    struct.field @cubed : !struct.type<@Reg<[]>> {column}
    function.def @compute(%arg0: !felt.type) -> !struct.type<@SBox<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@SBox<[]>>
      %0 = felt.mul %arg0, %arg0 : !felt.type, !felt.type
      %1 = felt.mul %0, %arg0 : !felt.type, !felt.type
      %2 = function.call @Reg::@compute(%1) : (!felt.type) -> !struct.type<@Reg<[]>>
      struct.writef %self[@cubed] = %2 : <@SBox<[]>>, !struct.type<@Reg<[]>>
      %3 = struct.readf %self[@cubed] : <@SBox<[]>>, !struct.type<@Reg<[]>>
      %4 = struct.readf %3[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %5 = struct.readf %4[@"$super"] : <@NondetReg<[]>>, !felt.type
      %6 = struct.readf %3[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %7 = struct.readf %6[@"$super"] : <@NondetReg<[]>>, !felt.type
      %8 = felt.mul %5, %7 : !felt.type, !felt.type
      %9 = felt.mul %8, %arg0 : !felt.type, !felt.type
      %10 = function.call @Reg::@compute(%9) : (!felt.type) -> !struct.type<@Reg<[]>>
      struct.writef %self[@out] = %10 : <@SBox<[]>>, !struct.type<@Reg<[]>>
      %11 = struct.readf %self[@out] : <@SBox<[]>>, !struct.type<@Reg<[]>>
      struct.writef %self[@"$super"] = %11 : <@SBox<[]>>, !struct.type<@Reg<[]>>
      function.return %self : !struct.type<@SBox<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@SBox<[]>>, %arg1: !felt.type) attributes {function.allow_constraint} {
      %0 = felt.mul %arg1, %arg1 : !felt.type, !felt.type
      %1 = felt.mul %0, %arg1 : !felt.type, !felt.type
      %2 = struct.readf %arg0[@cubed] : <@SBox<[]>>, !struct.type<@Reg<[]>>
      function.call @Reg::@constrain(%2, %1) : (!struct.type<@Reg<[]>>, !felt.type) -> ()
      %3 = struct.readf %2[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %4 = struct.readf %3[@"$super"] : <@NondetReg<[]>>, !felt.type
      %5 = struct.readf %2[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %6 = struct.readf %5[@"$super"] : <@NondetReg<[]>>, !felt.type
      %7 = felt.mul %4, %6 : !felt.type, !felt.type
      %8 = felt.mul %7, %arg1 : !felt.type, !felt.type
      %9 = struct.readf %arg0[@out] : <@SBox<[]>>, !struct.type<@Reg<[]>>
      function.call @Reg::@constrain(%9, %8) : (!struct.type<@Reg<[]>>, !felt.type) -> ()
      function.return
    }
  }
  struct.def @DoIntRound<[]> {
    struct.field @"$super" : !struct.type<@MultiplyByMInt<[]>>
    struct.field @"$temp" : !struct.type<@MultiplyByMInt<[]>>
    struct.field @mat_in : !array.type<24 x !felt.type>
    struct.field @sbox : !struct.type<@SBox<[]>> {column}
    struct.field @x : !felt.type
    function.def @compute(%arg0: !array.type<24 x !felt.type>, %arg1: !felt.type) -> !struct.type<@DoIntRound<[]>> attributes {function.allow_witness} {
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@DoIntRound<[]>>
      %0 = cast.toindex %felt_const_0
      %1 = array.read %arg0[%0] : <24 x !felt.type>, !felt.type
      %2 = felt.add %1, %arg1 : !felt.type, !felt.type
      struct.writef %self[@x] = %2 : <@DoIntRound<[]>>, !felt.type
      %3 = function.call @SBox::@compute(%2) : (!felt.type) -> !struct.type<@SBox<[]>>
      struct.writef %self[@sbox] = %3 : <@DoIntRound<[]>>, !struct.type<@SBox<[]>>
      %4 = struct.readf %self[@sbox] : <@DoIntRound<[]>>, !struct.type<@SBox<[]>>
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !felt.type>
      scf.for %arg2 = %c0 to %c24 step %c1 {
        %9 = array.read %array[%arg2] : <24 x !felt.type>, !felt.type
        %10 = bool.cmp eq(%9, %felt_const_0)
        %11 = cast.tofelt %10 : i1
        %12 = struct.readf %4[@"$super"] : <@SBox<[]>>, !struct.type<@Reg<[]>>
        %13 = struct.readf %12[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %14 = struct.readf %13[@"$super"] : <@NondetReg<[]>>, !felt.type
        %15 = felt.mul %11, %14 : !felt.type, !felt.type
        %16 = bool.cmp eq(%9, %felt_const_0)
        %17 = cast.tofelt %16 : i1
        %18 = felt.sub %felt_const_1, %17 : !felt.type, !felt.type
        %19 = cast.toindex %9
        %20 = array.read %arg0[%19] : <24 x !felt.type>, !felt.type
        %21 = felt.mul %18, %20 : !felt.type, !felt.type
        %22 = felt.add %15, %21 : !felt.type, !felt.type
        array.write %array_0[%arg2] = %22 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@mat_in] = %array_0 : <@DoIntRound<[]>>, !array.type<24 x !felt.type>
      %5 = struct.readf %self[@mat_in] : <@DoIntRound<[]>>, !array.type<24 x !felt.type>
      %6 = poly.unifiable_cast %5 : (!array.type<24 x !felt.type>) -> !array.type<24 x !felt.type>
      %7 = function.call @MultiplyByMInt::@compute(%6) : (!array.type<24 x !felt.type>) -> !struct.type<@MultiplyByMInt<[]>>
      struct.writef %self[@"$temp"] = %7 : <@DoIntRound<[]>>, !struct.type<@MultiplyByMInt<[]>>
      %8 = struct.readf %self[@"$temp"] : <@DoIntRound<[]>>, !struct.type<@MultiplyByMInt<[]>>
      struct.writef %self[@"$super"] = %8 : <@DoIntRound<[]>>, !struct.type<@MultiplyByMInt<[]>>
      function.return %self : !struct.type<@DoIntRound<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@DoIntRound<[]>>, %arg1: !array.type<24 x !felt.type>, %arg2: !felt.type) attributes {function.allow_constraint} {
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %0 = cast.toindex %felt_const_0
      %1 = array.read %arg1[%0] : <24 x !felt.type>, !felt.type
      %2 = felt.add %1, %arg2 : !felt.type, !felt.type
      %3 = struct.readf %arg0[@sbox] : <@DoIntRound<[]>>, !struct.type<@SBox<[]>>
      function.call @SBox::@constrain(%3, %2) : (!struct.type<@SBox<[]>>, !felt.type) -> ()
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !felt.type>
      scf.for %arg3 = %c0 to %c24 step %c1 {
        %7 = array.read %array[%arg3] : <24 x !felt.type>, !felt.type
        %8 = bool.cmp eq(%7, %felt_const_0)
        %9 = cast.tofelt %8 : i1
        %10 = struct.readf %3[@"$super"] : <@SBox<[]>>, !struct.type<@Reg<[]>>
        %11 = struct.readf %10[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %12 = struct.readf %11[@"$super"] : <@NondetReg<[]>>, !felt.type
        %13 = felt.mul %9, %12 : !felt.type, !felt.type
        %14 = bool.cmp eq(%7, %felt_const_0)
        %15 = cast.tofelt %14 : i1
        %16 = felt.sub %felt_const_1, %15 : !felt.type, !felt.type
        %17 = cast.toindex %7
        %18 = array.read %arg1[%17] : <24 x !felt.type>, !felt.type
        %19 = felt.mul %16, %18 : !felt.type, !felt.type
        %20 = felt.add %13, %19 : !felt.type, !felt.type
        array.write %array_0[%arg3] = %20 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      %4 = struct.readf %arg0[@mat_in] : <@DoIntRound<[]>>, !array.type<24 x !felt.type>
      %5 = poly.unifiable_cast %4 : (!array.type<24 x !felt.type>) -> !array.type<24 x !felt.type>
      %6 = struct.readf %arg0[@"$temp"] : <@DoIntRound<[]>>, !struct.type<@MultiplyByMInt<[]>>
      function.call @MultiplyByMInt::@constrain(%6, %5) : (!struct.type<@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>) -> ()
      function.return
    }
  }
  struct.def @DoIntRounds<[]> {
    struct.field @"$super" : !array.type<24 x !felt.type>
    struct.field @"$temp_0" : !array.type<21 x !struct.type<@DoIntRound<[]>>>
    struct.field @"$array" : !array.type<21 x !felt.type>
    struct.field @"$temp" : !struct.type<@INT_ROUND_CONSTANTS<[]>>
    function.def @compute(%arg0: !array.type<24 x !felt.type>) -> !struct.type<@DoIntRounds<[]>> attributes {function.allow_witness} {
      %c21 = arith.constant 21 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %self = struct.new : !struct.type<@DoIntRounds<[]>>
      %0 = function.call @INT_ROUND_CONSTANTS::@compute() : () -> !struct.type<@INT_ROUND_CONSTANTS<[]>>
      struct.writef %self[@"$temp"] = %0 : <@DoIntRounds<[]>>, !struct.type<@INT_ROUND_CONSTANTS<[]>>
      %1 = struct.readf %self[@"$temp"] : <@DoIntRounds<[]>>, !struct.type<@INT_ROUND_CONSTANTS<[]>>
      %2 = struct.readf %1[@"$super"] : <@INT_ROUND_CONSTANTS<[]>>, !array.type<21 x !felt.type>
      %array = array.new  : <21 x !felt.type>
      scf.for %arg1 = %c0 to %c21 step %c1 {
        %5 = array.read %2[%arg1] : <21 x !felt.type>, !felt.type
        array.write %array[%arg1] = %5 : <21 x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array : <@DoIntRounds<[]>>, !array.type<21 x !felt.type>
      %3 = struct.readf %self[@"$array"] : <@DoIntRounds<[]>>, !array.type<21 x !felt.type>
      %4 = scf.for %arg1 = %c0 to %c21 step %c1 iter_args(%arg2 = %arg0) -> (!array.type<24 x !felt.type>) {
        %5 = array.read %3[%arg1] : <21 x !felt.type>, !felt.type
        %6 = function.call @DoIntRound::@compute(%arg2, %5) : (!array.type<24 x !felt.type>, !felt.type) -> !struct.type<@DoIntRound<[]>>
        %7 = struct.readf %self[@"$temp_0"] : <@DoIntRounds<[]>>, !array.type<21 x !struct.type<@DoIntRound<[]>>>
        array.write %7[%arg1] = %6 : <21 x !struct.type<@DoIntRound<[]>>>, !struct.type<@DoIntRound<[]>>
        struct.writef %self[@"$temp_0"] = %7 : <@DoIntRounds<[]>>, !array.type<21 x !struct.type<@DoIntRound<[]>>>
        %8 = struct.readf %self[@"$temp_0"] : <@DoIntRounds<[]>>, !array.type<21 x !struct.type<@DoIntRound<[]>>>
        %9 = array.read %8[%arg1] : <21 x !struct.type<@DoIntRound<[]>>>, !struct.type<@DoIntRound<[]>>
        %10 = struct.readf %9[@"$super"] : <@DoIntRound<[]>>, !struct.type<@MultiplyByMInt<[]>>
        %11 = struct.readf %10[@"$super"] : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
        %12 = poly.unifiable_cast %11 : (!array.type<24 x !felt.type>) -> !array.type<24 x !felt.type>
        scf.yield %12 : !array.type<24 x !felt.type>
      } {original_op = "reduce"}
      struct.writef %self[@"$super"] = %4 : <@DoIntRounds<[]>>, !array.type<24 x !felt.type>
      function.return %self : !struct.type<@DoIntRounds<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@DoIntRounds<[]>>, %arg1: !array.type<24 x !felt.type>) attributes {function.allow_constraint} {
      %c21 = arith.constant 21 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %0 = struct.readf %arg0[@"$temp"] : <@DoIntRounds<[]>>, !struct.type<@INT_ROUND_CONSTANTS<[]>>
      function.call @INT_ROUND_CONSTANTS::@constrain(%0) : (!struct.type<@INT_ROUND_CONSTANTS<[]>>) -> ()
      %1 = struct.readf %0[@"$super"] : <@INT_ROUND_CONSTANTS<[]>>, !array.type<21 x !felt.type>
      %array = array.new  : <21 x !felt.type>
      scf.for %arg2 = %c0 to %c21 step %c1 {
        %4 = array.read %1[%arg2] : <21 x !felt.type>, !felt.type
        array.write %array[%arg2] = %4 : <21 x !felt.type>, !felt.type
      } {original_op = "map"}
      %2 = struct.readf %arg0[@"$array"] : <@DoIntRounds<[]>>, !array.type<21 x !felt.type>
      %3 = scf.for %arg2 = %c0 to %c21 step %c1 iter_args(%arg3 = %arg1) -> (!array.type<24 x !felt.type>) {
        %4 = array.read %2[%arg2] : <21 x !felt.type>, !felt.type
        %5 = struct.readf %arg0[@"$temp_0"] : <@DoIntRounds<[]>>, !array.type<21 x !struct.type<@DoIntRound<[]>>>
        %6 = struct.readf %arg0[@"$temp_0"] : <@DoIntRounds<[]>>, !array.type<21 x !struct.type<@DoIntRound<[]>>>
        %7 = array.read %6[%arg2] : <21 x !struct.type<@DoIntRound<[]>>>, !struct.type<@DoIntRound<[]>>
        function.call @DoIntRound::@constrain(%7, %arg3, %4) : (!struct.type<@DoIntRound<[]>>, !array.type<24 x !felt.type>, !felt.type) -> ()
        %8 = struct.readf %7[@"$super"] : <@DoIntRound<[]>>, !struct.type<@MultiplyByMInt<[]>>
        %9 = struct.readf %8[@"$super"] : <@MultiplyByMInt<[]>>, !array.type<24 x !felt.type>
        %10 = poly.unifiable_cast %9 : (!array.type<24 x !felt.type>) -> !array.type<24 x !felt.type>
        scf.yield %10 : !array.type<24 x !felt.type>
      } {original_op = "reduce"}
      function.return
    }
  }
  struct.def @MultiplyByCirculant<[]> {
    struct.field @"$super" : !array.type<4 x !felt.type>
    struct.field @t7 : !felt.type
    struct.field @t6 : !felt.type
    struct.field @t5 : !felt.type
    struct.field @t4 : !felt.type
    struct.field @t3 : !felt.type
    struct.field @t2 : !felt.type
    struct.field @t1 : !felt.type
    struct.field @t0 : !felt.type
    function.def @compute(%arg0: !array.type<4 x !felt.type>) -> !struct.type<@MultiplyByCirculant<[]>> attributes {function.allow_witness} {
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@MultiplyByCirculant<[]>>
      %0 = cast.toindex %felt_const_0
      %1 = array.read %arg0[%0] : <4 x !felt.type>, !felt.type
      %2 = cast.toindex %felt_const_1
      %3 = array.read %arg0[%2] : <4 x !felt.type>, !felt.type
      %4 = felt.add %1, %3 : !felt.type, !felt.type
      struct.writef %self[@t0] = %4 : <@MultiplyByCirculant<[]>>, !felt.type
      %5 = cast.toindex %felt_const_2
      %6 = array.read %arg0[%5] : <4 x !felt.type>, !felt.type
      %7 = cast.toindex %felt_const_3
      %8 = array.read %arg0[%7] : <4 x !felt.type>, !felt.type
      %9 = felt.add %6, %8 : !felt.type, !felt.type
      struct.writef %self[@t1] = %9 : <@MultiplyByCirculant<[]>>, !felt.type
      %10 = cast.toindex %felt_const_1
      %11 = array.read %arg0[%10] : <4 x !felt.type>, !felt.type
      %12 = felt.mul %11, %felt_const_2 : !felt.type, !felt.type
      %13 = felt.add %12, %9 : !felt.type, !felt.type
      struct.writef %self[@t2] = %13 : <@MultiplyByCirculant<[]>>, !felt.type
      %14 = cast.toindex %felt_const_3
      %15 = array.read %arg0[%14] : <4 x !felt.type>, !felt.type
      %16 = felt.mul %15, %felt_const_2 : !felt.type, !felt.type
      %17 = felt.add %16, %4 : !felt.type, !felt.type
      struct.writef %self[@t3] = %17 : <@MultiplyByCirculant<[]>>, !felt.type
      %18 = felt.mul %9, %felt_const_4 : !felt.type, !felt.type
      %19 = felt.add %18, %17 : !felt.type, !felt.type
      struct.writef %self[@t4] = %19 : <@MultiplyByCirculant<[]>>, !felt.type
      %20 = felt.mul %4, %felt_const_4 : !felt.type, !felt.type
      %21 = felt.add %20, %13 : !felt.type, !felt.type
      struct.writef %self[@t5] = %21 : <@MultiplyByCirculant<[]>>, !felt.type
      %22 = felt.add %17, %21 : !felt.type, !felt.type
      struct.writef %self[@t6] = %22 : <@MultiplyByCirculant<[]>>, !felt.type
      %23 = felt.add %13, %19 : !felt.type, !felt.type
      struct.writef %self[@t7] = %23 : <@MultiplyByCirculant<[]>>, !felt.type
      %array = array.new %22, %21, %23, %19 : <4 x !felt.type>
      struct.writef %self[@"$super"] = %array : <@MultiplyByCirculant<[]>>, !array.type<4 x !felt.type>
      function.return %self : !struct.type<@MultiplyByCirculant<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@MultiplyByCirculant<[]>>, %arg1: !array.type<4 x !felt.type>) attributes {function.allow_constraint} {
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %0 = cast.toindex %felt_const_0
      %1 = array.read %arg1[%0] : <4 x !felt.type>, !felt.type
      %2 = cast.toindex %felt_const_1
      %3 = array.read %arg1[%2] : <4 x !felt.type>, !felt.type
      %4 = cast.toindex %felt_const_2
      %5 = array.read %arg1[%4] : <4 x !felt.type>, !felt.type
      %6 = cast.toindex %felt_const_3
      %7 = array.read %arg1[%6] : <4 x !felt.type>, !felt.type
      %8 = cast.toindex %felt_const_1
      %9 = array.read %arg1[%8] : <4 x !felt.type>, !felt.type
      %10 = cast.toindex %felt_const_3
      %11 = array.read %arg1[%10] : <4 x !felt.type>, !felt.type
      function.return
    }
  }
  struct.def @ReduceVec4<[]> {
    struct.field @"$super" : !array.type<4 x !felt.type>
    struct.field @"$array" : !array.type<4 x !felt.type>
    function.def @compute(%arg0: !array.type<4 x !felt.type>, %arg1: !array.type<4 x !felt.type>) -> !struct.type<@ReduceVec4<[]>> attributes {function.allow_witness} {
      %c4 = arith.constant 4 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@ReduceVec4<[]>>
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3 : <4 x !felt.type>
      %array_0 = array.new  : <4 x !felt.type>
      scf.for %arg2 = %c0 to %c4 step %c1 {
        %1 = array.read %array[%arg2] : <4 x !felt.type>, !felt.type
        %2 = cast.toindex %1
        %3 = array.read %arg0[%2] : <4 x !felt.type>, !felt.type
        %4 = cast.toindex %1
        %5 = array.read %arg1[%4] : <4 x !felt.type>, !felt.type
        %6 = felt.add %3, %5 : !felt.type, !felt.type
        array.write %array_0[%arg2] = %6 : <4 x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_0 : <@ReduceVec4<[]>>, !array.type<4 x !felt.type>
      %0 = struct.readf %self[@"$array"] : <@ReduceVec4<[]>>, !array.type<4 x !felt.type>
      struct.writef %self[@"$super"] = %0 : <@ReduceVec4<[]>>, !array.type<4 x !felt.type>
      function.return %self : !struct.type<@ReduceVec4<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@ReduceVec4<[]>>, %arg1: !array.type<4 x !felt.type>, %arg2: !array.type<4 x !felt.type>) attributes {function.allow_constraint} {
      %c4 = arith.constant 4 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_0 = felt.const 0
      %felt_const_1 = felt.const 1
      %felt_const_2 = felt.const 2
      %felt_const_3 = felt.const 3
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3 : <4 x !felt.type>
      %array_0 = array.new  : <4 x !felt.type>
      scf.for %arg3 = %c0 to %c4 step %c1 {
        %1 = array.read %array[%arg3] : <4 x !felt.type>, !felt.type
        %2 = cast.toindex %1
        %3 = array.read %arg1[%2] : <4 x !felt.type>, !felt.type
        %4 = cast.toindex %1
        %5 = array.read %arg2[%4] : <4 x !felt.type>, !felt.type
        %6 = felt.add %3, %5 : !felt.type, !felt.type
        array.write %array_0[%arg3] = %6 : <4 x !felt.type>, !felt.type
      } {original_op = "map"}
      %0 = struct.readf %arg0[@"$array"] : <@ReduceVec4<[]>>, !array.type<4 x !felt.type>
      function.return
    }
  }
  struct.def @MultiplyByMExt<[]> {
    struct.field @"$super" : !array.type<24 x !struct.type<@block$<[]>>>
    struct.field @"$temp_2" : !array.type<24 x !struct.type<@block$<[]>>>
    struct.field @g : !array.type<24 x !felt.type>
    struct.field @j : !array.type<24 x !struct.type<@BitAnd<[]>>>
    struct.field @"$array" : !array.type<24 x !struct.type<@block$<[]>>>
    struct.field @"$temp_1" : !array.type<6 x !struct.type<@ReduceVec4<[]>>>
    struct.field @"$temp_0" : !array.type<6 x !struct.type<@block$_2<[]>>>
    struct.field @"$temp" : !array.type<6 x !struct.type<@MultiplyByCirculant<[]>>>
    struct.field @chunk : !array.type<6,4 x !felt.type>
    struct.field @grouped : !array.type<6 x !struct.type<@block$_2<[]>>>
    function.def @compute(%arg0: !array.type<24 x !felt.type>) -> !struct.type<@MultiplyByMExt<[]>> attributes {function.allow_witness} {
      %felt_const_1509949441 = felt.const 1509949441
      %c24 = arith.constant 24 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %c4 = arith.constant 4 : index
      %c6 = arith.constant 6 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@MultiplyByMExt<[]>>
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5 : <6 x !felt.type>
      %array_0 = array.new  : <6 x !struct.type<@block$_2<[]>>>
      scf.for %arg1 = %c0 to %c6 step %c1 {
        %3 = array.read %array[%arg1] : <6 x !felt.type>, !felt.type
        %array_4 = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3 : <4 x !felt.type>
        %array_5 = array.new  : <4 x !felt.type>
        scf.for %arg2 = %c0 to %c4 step %c1 {
          %17 = array.read %array_4[%arg2] : <4 x !felt.type>, !felt.type
          %18 = felt.mul %3, %felt_const_4 : !felt.type, !felt.type
          %19 = felt.add %18, %17 : !felt.type, !felt.type
          %20 = cast.toindex %19
          %21 = array.read %arg0[%20] : <24 x !felt.type>, !felt.type
          array.write %array_5[%arg2] = %21 : <4 x !felt.type>, !felt.type
        } {original_op = "map"}
        %4 = struct.readf %self[@chunk] : <@MultiplyByMExt<[]>>, !array.type<6,4 x !felt.type>
        array.insert %4[%arg1] = %array_5 : <6,4 x !felt.type>, <4 x !felt.type>
        struct.writef %self[@chunk] = %4 : <@MultiplyByMExt<[]>>, !array.type<6,4 x !felt.type>
        %5 = struct.readf %self[@chunk] : <@MultiplyByMExt<[]>>, !array.type<6,4 x !felt.type>
        %6 = array.extract %5[%arg1] : <6,4 x !felt.type>
        %7 = function.call @MultiplyByCirculant::@compute(%6) : (!array.type<4 x !felt.type>) -> !struct.type<@MultiplyByCirculant<[]>>
        %8 = struct.readf %self[@"$temp"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@MultiplyByCirculant<[]>>>
        array.write %8[%arg1] = %7 : <6 x !struct.type<@MultiplyByCirculant<[]>>>, !struct.type<@MultiplyByCirculant<[]>>
        struct.writef %self[@"$temp"] = %8 : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@MultiplyByCirculant<[]>>>
        %9 = struct.readf %self[@"$temp"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@MultiplyByCirculant<[]>>>
        %10 = array.read %9[%arg1] : <6 x !struct.type<@MultiplyByCirculant<[]>>>, !struct.type<@MultiplyByCirculant<[]>>
        %11 = struct.readf %self[@chunk] : <@MultiplyByMExt<[]>>, !array.type<6,4 x !felt.type>
        %12 = array.extract %11[%arg1] : <6,4 x !felt.type>
        %13 = function.call @block$_2::@compute(%10, %12) : (!struct.type<@MultiplyByCirculant<[]>>, !array.type<4 x !felt.type>) -> !struct.type<@block$_2<[]>>
        %14 = struct.readf %self[@"$temp_0"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@block$_2<[]>>>
        array.write %14[%arg1] = %13 : <6 x !struct.type<@block$_2<[]>>>, !struct.type<@block$_2<[]>>
        struct.writef %self[@"$temp_0"] = %14 : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@block$_2<[]>>>
        %15 = struct.readf %self[@"$temp_0"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@block$_2<[]>>>
        %16 = array.read %15[%arg1] : <6 x !struct.type<@block$_2<[]>>>, !struct.type<@block$_2<[]>>
        array.write %array_0[%arg1] = %16 : <6 x !struct.type<@block$_2<[]>>>, !struct.type<@block$_2<[]>>
      } {original_op = "map"}
      struct.writef %self[@grouped] = %array_0 : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@block$_2<[]>>>
      %0 = struct.readf %self[@grouped] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@block$_2<[]>>>
      %array_1 = array.new %felt_const_0, %felt_const_0, %felt_const_0, %felt_const_0 : <4 x !felt.type>
      %1 = scf.for %arg1 = %c0 to %c6 step %c1 iter_args(%arg2 = %array_1) -> (!array.type<4 x !felt.type>) {
        %3 = array.read %0[%arg1] : <6 x !struct.type<@block$_2<[]>>>, !struct.type<@block$_2<[]>>
        %4 = struct.readf %3[@"$super"] : <@block$_2<[]>>, !struct.type<@MultiplyByCirculant<[]>>
        %5 = struct.readf %4[@"$super"] : <@MultiplyByCirculant<[]>>, !array.type<4 x !felt.type>
        %6 = poly.unifiable_cast %5 : (!array.type<4 x !felt.type>) -> !array.type<4 x !felt.type>
        %7 = function.call @ReduceVec4::@compute(%arg2, %6) : (!array.type<4 x !felt.type>, !array.type<4 x !felt.type>) -> !struct.type<@ReduceVec4<[]>>
        %8 = struct.readf %self[@"$temp_1"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@ReduceVec4<[]>>>
        array.write %8[%arg1] = %7 : <6 x !struct.type<@ReduceVec4<[]>>>, !struct.type<@ReduceVec4<[]>>
        struct.writef %self[@"$temp_1"] = %8 : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@ReduceVec4<[]>>>
        %9 = struct.readf %self[@"$temp_1"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@ReduceVec4<[]>>>
        %10 = array.read %9[%arg1] : <6 x !struct.type<@ReduceVec4<[]>>>, !struct.type<@ReduceVec4<[]>>
        %11 = struct.readf %10[@"$super"] : <@ReduceVec4<[]>>, !array.type<4 x !felt.type>
        %12 = poly.unifiable_cast %11 : (!array.type<4 x !felt.type>) -> !array.type<4 x !felt.type>
        scf.yield %12 : !array.type<4 x !felt.type>
      } {original_op = "reduce"}
      %array_2 = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_3 = array.new  : <24 x !struct.type<@block$<[]>>>
      scf.for %arg1 = %c0 to %c24 step %c1 {
        %3 = array.read %array_2[%arg1] : <24 x !felt.type>, !felt.type
        %4 = function.call @BitAnd::@compute(%3, %felt_const_3) : (!felt.type, !felt.type) -> !struct.type<@BitAnd<[]>>
        %5 = struct.readf %self[@j] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@BitAnd<[]>>>
        array.write %5[%arg1] = %4 : <24 x !struct.type<@BitAnd<[]>>>, !struct.type<@BitAnd<[]>>
        struct.writef %self[@j] = %5 : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@BitAnd<[]>>>
        %6 = struct.readf %self[@j] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@BitAnd<[]>>>
        %7 = array.read %6[%arg1] : <24 x !struct.type<@BitAnd<[]>>>, !struct.type<@BitAnd<[]>>
        %8 = struct.readf %7[@"$super"] : <@BitAnd<[]>>, !felt.type
        %9 = felt.sub %3, %8 : !felt.type, !felt.type
        %10 = felt.mul %9, %felt_const_1509949441 : !felt.type, !felt.type
        %11 = struct.readf %self[@g] : <@MultiplyByMExt<[]>>, !array.type<24 x !felt.type>
        array.write %11[%arg1] = %10 : <24 x !felt.type>, !felt.type
        struct.writef %self[@g] = %11 : <@MultiplyByMExt<[]>>, !array.type<24 x !felt.type>
        %12 = cast.toindex %10
        %13 = array.read %0[%12] : <6 x !struct.type<@block$_2<[]>>>, !struct.type<@block$_2<[]>>
        %14 = struct.readf %13[@"$super"] : <@block$_2<[]>>, !struct.type<@MultiplyByCirculant<[]>>
        %15 = struct.readf %14[@"$super"] : <@MultiplyByCirculant<[]>>, !array.type<4 x !felt.type>
        %16 = struct.readf %7[@"$super"] : <@BitAnd<[]>>, !felt.type
        %17 = cast.toindex %16
        %18 = array.read %15[%17] : <4 x !felt.type>, !felt.type
        %19 = struct.readf %7[@"$super"] : <@BitAnd<[]>>, !felt.type
        %20 = cast.toindex %19
        %21 = array.read %1[%20] : <4 x !felt.type>, !felt.type
        %22 = felt.add %18, %21 : !felt.type, !felt.type
        %23 = struct.readf %self[@g] : <@MultiplyByMExt<[]>>, !array.type<24 x !felt.type>
        %24 = array.read %23[%arg1] : <24 x !felt.type>, !felt.type
        %25 = struct.readf %self[@j] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@BitAnd<[]>>>
        %26 = array.read %25[%arg1] : <24 x !struct.type<@BitAnd<[]>>>, !struct.type<@BitAnd<[]>>
        %27 = function.call @block$::@compute(%22, %24, %26) : (!felt.type, !felt.type, !struct.type<@BitAnd<[]>>) -> !struct.type<@block$<[]>>
        %28 = struct.readf %self[@"$temp_2"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
        array.write %28[%arg1] = %27 : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
        struct.writef %self[@"$temp_2"] = %28 : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
        %29 = struct.readf %self[@"$temp_2"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
        %30 = array.read %29[%arg1] : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
        array.write %array_3[%arg1] = %30 : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_3 : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
      %2 = struct.readf %self[@"$array"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
      struct.writef %self[@"$super"] = %2 : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
      function.return %self : !struct.type<@MultiplyByMExt<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@MultiplyByMExt<[]>>, %arg1: !array.type<24 x !felt.type>) attributes {function.allow_constraint} {
      %felt_const_1509949441 = felt.const 1509949441
      %c24 = arith.constant 24 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %c4 = arith.constant 4 : index
      %c6 = arith.constant 6 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_0 = felt.const 0
      %felt_const_1 = felt.const 1
      %felt_const_2 = felt.const 2
      %felt_const_3 = felt.const 3
      %felt_const_4 = felt.const 4
      %felt_const_5 = felt.const 5
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5 : <6 x !felt.type>
      %array_0 = array.new  : <6 x !struct.type<@block$_2<[]>>>
      scf.for %arg2 = %c0 to %c6 step %c1 {
        %3 = array.read %array[%arg2] : <6 x !felt.type>, !felt.type
        %array_4 = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3 : <4 x !felt.type>
        %array_5 = array.new  : <4 x !felt.type>
        scf.for %arg3 = %c0 to %c4 step %c1 {
          %15 = array.read %array_4[%arg3] : <4 x !felt.type>, !felt.type
          %16 = felt.mul %3, %felt_const_4 : !felt.type, !felt.type
          %17 = felt.add %16, %15 : !felt.type, !felt.type
          %18 = cast.toindex %17
          %19 = array.read %arg1[%18] : <24 x !felt.type>, !felt.type
          array.write %array_5[%arg3] = %19 : <4 x !felt.type>, !felt.type
        } {original_op = "map"}
        %4 = struct.readf %arg0[@chunk] : <@MultiplyByMExt<[]>>, !array.type<6,4 x !felt.type>
        %5 = struct.readf %arg0[@chunk] : <@MultiplyByMExt<[]>>, !array.type<6,4 x !felt.type>
        %6 = array.extract %5[%arg2] : <6,4 x !felt.type>
        %7 = struct.readf %arg0[@"$temp"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@MultiplyByCirculant<[]>>>
        %8 = struct.readf %arg0[@"$temp"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@MultiplyByCirculant<[]>>>
        %9 = array.read %8[%arg2] : <6 x !struct.type<@MultiplyByCirculant<[]>>>, !struct.type<@MultiplyByCirculant<[]>>
        function.call @MultiplyByCirculant::@constrain(%9, %6) : (!struct.type<@MultiplyByCirculant<[]>>, !array.type<4 x !felt.type>) -> ()
        %10 = struct.readf %arg0[@chunk] : <@MultiplyByMExt<[]>>, !array.type<6,4 x !felt.type>
        %11 = array.extract %10[%arg2] : <6,4 x !felt.type>
        %12 = struct.readf %arg0[@"$temp_0"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@block$_2<[]>>>
        %13 = struct.readf %arg0[@"$temp_0"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@block$_2<[]>>>
        %14 = array.read %13[%arg2] : <6 x !struct.type<@block$_2<[]>>>, !struct.type<@block$_2<[]>>
        function.call @block$_2::@constrain(%14, %9, %11) : (!struct.type<@block$_2<[]>>, !struct.type<@MultiplyByCirculant<[]>>, !array.type<4 x !felt.type>) -> ()
        array.write %array_0[%arg2] = %14 : <6 x !struct.type<@block$_2<[]>>>, !struct.type<@block$_2<[]>>
      } {original_op = "map"}
      %0 = struct.readf %arg0[@grouped] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@block$_2<[]>>>
      %array_1 = array.new %felt_const_0, %felt_const_0, %felt_const_0, %felt_const_0 : <4 x !felt.type>
      %1 = scf.for %arg2 = %c0 to %c6 step %c1 iter_args(%arg3 = %array_1) -> (!array.type<4 x !felt.type>) {
        %3 = array.read %0[%arg2] : <6 x !struct.type<@block$_2<[]>>>, !struct.type<@block$_2<[]>>
        %4 = struct.readf %3[@"$super"] : <@block$_2<[]>>, !struct.type<@MultiplyByCirculant<[]>>
        %5 = struct.readf %4[@"$super"] : <@MultiplyByCirculant<[]>>, !array.type<4 x !felt.type>
        %6 = poly.unifiable_cast %5 : (!array.type<4 x !felt.type>) -> !array.type<4 x !felt.type>
        %7 = struct.readf %arg0[@"$temp_1"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@ReduceVec4<[]>>>
        %8 = struct.readf %arg0[@"$temp_1"] : <@MultiplyByMExt<[]>>, !array.type<6 x !struct.type<@ReduceVec4<[]>>>
        %9 = array.read %8[%arg2] : <6 x !struct.type<@ReduceVec4<[]>>>, !struct.type<@ReduceVec4<[]>>
        function.call @ReduceVec4::@constrain(%9, %arg3, %6) : (!struct.type<@ReduceVec4<[]>>, !array.type<4 x !felt.type>, !array.type<4 x !felt.type>) -> ()
        %10 = struct.readf %9[@"$super"] : <@ReduceVec4<[]>>, !array.type<4 x !felt.type>
        %11 = poly.unifiable_cast %10 : (!array.type<4 x !felt.type>) -> !array.type<4 x !felt.type>
        scf.yield %11 : !array.type<4 x !felt.type>
      } {original_op = "reduce"}
      %array_2 = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_3 = array.new  : <24 x !struct.type<@block$<[]>>>
      scf.for %arg2 = %c0 to %c24 step %c1 {
        %3 = array.read %array_2[%arg2] : <24 x !felt.type>, !felt.type
        %4 = struct.readf %arg0[@j] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@BitAnd<[]>>>
        %5 = struct.readf %arg0[@j] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@BitAnd<[]>>>
        %6 = array.read %5[%arg2] : <24 x !struct.type<@BitAnd<[]>>>, !struct.type<@BitAnd<[]>>
        function.call @BitAnd::@constrain(%6, %3, %felt_const_3) : (!struct.type<@BitAnd<[]>>, !felt.type, !felt.type) -> ()
        %7 = struct.readf %6[@"$super"] : <@BitAnd<[]>>, !felt.type
        %8 = felt.sub %3, %7 : !felt.type, !felt.type
        %9 = felt.mul %8, %felt_const_1509949441 : !felt.type, !felt.type
        %10 = struct.readf %arg0[@g] : <@MultiplyByMExt<[]>>, !array.type<24 x !felt.type>
        %11 = cast.toindex %9
        %12 = array.read %0[%11] : <6 x !struct.type<@block$_2<[]>>>, !struct.type<@block$_2<[]>>
        %13 = struct.readf %12[@"$super"] : <@block$_2<[]>>, !struct.type<@MultiplyByCirculant<[]>>
        %14 = struct.readf %13[@"$super"] : <@MultiplyByCirculant<[]>>, !array.type<4 x !felt.type>
        %15 = struct.readf %6[@"$super"] : <@BitAnd<[]>>, !felt.type
        %16 = cast.toindex %15
        %17 = array.read %14[%16] : <4 x !felt.type>, !felt.type
        %18 = struct.readf %6[@"$super"] : <@BitAnd<[]>>, !felt.type
        %19 = cast.toindex %18
        %20 = array.read %1[%19] : <4 x !felt.type>, !felt.type
        %21 = felt.add %17, %20 : !felt.type, !felt.type
        %22 = struct.readf %arg0[@g] : <@MultiplyByMExt<[]>>, !array.type<24 x !felt.type>
        %23 = array.read %22[%arg2] : <24 x !felt.type>, !felt.type
        %24 = struct.readf %arg0[@j] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@BitAnd<[]>>>
        %25 = array.read %24[%arg2] : <24 x !struct.type<@BitAnd<[]>>>, !struct.type<@BitAnd<[]>>
        %26 = struct.readf %arg0[@"$temp_2"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
        %27 = struct.readf %arg0[@"$temp_2"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
        %28 = array.read %27[%arg2] : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
        function.call @block$::@constrain(%28, %21, %23, %25) : (!struct.type<@block$<[]>>, !felt.type, !felt.type, !struct.type<@BitAnd<[]>>) -> ()
        array.write %array_3[%arg2] = %28 : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
      } {original_op = "map"}
      %2 = struct.readf %arg0[@"$array"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
      function.return
    }
  }
  struct.def @ExtRoundConstants<[]> {
    struct.field @"$super" : !array.type<8,24 x !felt.type>
    function.def @compute() -> !struct.type<@ExtRoundConstants<[]>> attributes {function.allow_witness} {
      %c7 = arith.constant 7 : index
      %c6 = arith.constant 6 : index
      %c5 = arith.constant 5 : index
      %c4 = arith.constant 4 : index
      %c3 = arith.constant 3 : index
      %c2 = arith.constant 2 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %felt_const_1380248020 = felt.const 1380248020
      %felt_const_1608891156 = felt.const 1608891156
      %felt_const_1672219447 = felt.const 1672219447
      %felt_const_1262312258 = felt.const 1262312258
      %felt_const_162506101 = felt.const 162506101
      %felt_const_809508074 = felt.const 809508074
      %felt_const_1303271640 = felt.const 1303271640
      %felt_const_1393671120 = felt.const 1393671120
      %felt_const_641665156 = felt.const 641665156
      %felt_const_1090783436 = felt.const 1090783436
      %felt_const_1111203133 = felt.const 1111203133
      %felt_const_1296144415 = felt.const 1296144415
      %felt_const_202271745 = felt.const 202271745
      %felt_const_459826664 = felt.const 459826664
      %felt_const_781141772 = felt.const 781141772
      %felt_const_1832911930 = felt.const 1832911930
      %felt_const_228520958 = felt.const 228520958
      %felt_const_813674331 = felt.const 813674331
      %felt_const_1889898 = felt.const 1889898
      %felt_const_1124078057 = felt.const 1124078057
      %felt_const_738091882 = felt.const 738091882
      %felt_const_1003792297 = felt.const 1003792297
      %felt_const_1896271507 = felt.const 1896271507
      %felt_const_1206940496 = felt.const 1206940496
      %felt_const_1827572010 = felt.const 1827572010
      %felt_const_1507649755 = felt.const 1507649755
      %felt_const_1042892522 = felt.const 1042892522
      %felt_const_760115692 = felt.const 760115692
      %felt_const_1841795381 = felt.const 1841795381
      %felt_const_457372011 = felt.const 457372011
      %felt_const_1748789933 = felt.const 1748789933
      %felt_const_1478577620 = felt.const 1478577620
      %felt_const_76770019 = felt.const 76770019
      %felt_const_1293938517 = felt.const 1293938517
      %felt_const_1150410028 = felt.const 1150410028
      %felt_const_1065075039 = felt.const 1065075039
      %felt_const_1198261138 = felt.const 1198261138
      %felt_const_59510015 = felt.const 59510015
      %felt_const_1402624179 = felt.const 1402624179
      %felt_const_158646617 = felt.const 158646617
      %felt_const_890243564 = felt.const 890243564
      %felt_const_1463323727 = felt.const 1463323727
      %felt_const_1080533265 = felt.const 1080533265
      %felt_const_192082241 = felt.const 192082241
      %felt_const_1891637550 = felt.const 1891637550
      %felt_const_1950429111 = felt.const 1950429111
      %felt_const_1663353317 = felt.const 1663353317
      %felt_const_1567618575 = felt.const 1567618575
      %felt_const_150307788 = felt.const 150307788
      %felt_const_755691969 = felt.const 755691969
      %felt_const_1715719711 = felt.const 1715719711
      %felt_const_1545325389 = felt.const 1545325389
      %felt_const_989618631 = felt.const 989618631
      %felt_const_1401020792 = felt.const 1401020792
      %felt_const_930036496 = felt.const 930036496
      %felt_const_238616145 = felt.const 238616145
      %felt_const_1006235079 = felt.const 1006235079
      %felt_const_942439428 = felt.const 942439428
      %felt_const_1649953458 = felt.const 1649953458
      %felt_const_1647665372 = felt.const 1647665372
      %felt_const_708123747 = felt.const 708123747
      %felt_const_925018226 = felt.const 925018226
      %felt_const_78845751 = felt.const 78845751
      %felt_const_1889603648 = felt.const 1889603648
      %felt_const_993455846 = felt.const 993455846
      %felt_const_140621810 = felt.const 140621810
      %felt_const_117294666 = felt.const 117294666
      %felt_const_790726260 = felt.const 790726260
      %felt_const_1213686459 = felt.const 1213686459
      %felt_const_390340387 = felt.const 390340387
      %felt_const_714957516 = felt.const 714957516
      %felt_const_1209164052 = felt.const 1209164052
      %felt_const_1040977421 = felt.const 1040977421
      %felt_const_1792450386 = felt.const 1792450386
      %felt_const_1470845646 = felt.const 1470845646
      %felt_const_1363837384 = felt.const 1363837384
      %felt_const_1878280202 = felt.const 1878280202
      %felt_const_434078361 = felt.const 434078361
      %felt_const_1946596189 = felt.const 1946596189
      %felt_const_875839332 = felt.const 875839332
      %felt_const_463976218 = felt.const 463976218
      %felt_const_976057819 = felt.const 976057819
      %felt_const_48375137 = felt.const 48375137
      %felt_const_1549779579 = felt.const 1549779579
      %felt_const_1679178250 = felt.const 1679178250
      %felt_const_530151394 = felt.const 530151394
      %felt_const_1629316321 = felt.const 1629316321
      %felt_const_1854174607 = felt.const 1854174607
      %felt_const_720724951 = felt.const 720724951
      %felt_const_14387587 = felt.const 14387587
      %felt_const_1883820770 = felt.const 1883820770
      %felt_const_205609311 = felt.const 205609311
      %felt_const_1136469704 = felt.const 1136469704
      %felt_const_1439947916 = felt.const 1439947916
      %felt_const_723038058 = felt.const 723038058
      %felt_const_53041581 = felt.const 53041581
      %felt_const_1291790245 = felt.const 1291790245
      %felt_const_1781980094 = felt.const 1781980094
      %felt_const_273790406 = felt.const 273790406
      %felt_const_1239734761 = felt.const 1239734761
      %felt_const_1221257987 = felt.const 1221257987
      %felt_const_51256176 = felt.const 51256176
      %felt_const_172614232 = felt.const 172614232
      %felt_const_306391314 = felt.const 306391314
      %felt_const_1647670797 = felt.const 1647670797
      %felt_const_53007114 = felt.const 53007114
      %felt_const_1269493554 = felt.const 1269493554
      %felt_const_1338899225 = felt.const 1338899225
      %felt_const_1740472809 = felt.const 1740472809
      %felt_const_1454563174 = felt.const 1454563174
      %felt_const_204228775 = felt.const 204228775
      %felt_const_588764636 = felt.const 588764636
      %felt_const_1718628547 = felt.const 1718628547
      %felt_const_427731030 = felt.const 427731030
      %felt_const_825405577 = felt.const 825405577
      %felt_const_342857858 = felt.const 342857858
      %felt_const_1290028279 = felt.const 1290028279
      %felt_const_608401422 = felt.const 608401422
      %felt_const_1587822577 = felt.const 1587822577
      %felt_const_128479034 = felt.const 128479034
      %felt_const_862495875 = felt.const 862495875
      %felt_const_447555988 = felt.const 447555988
      %felt_const_1910423126 = felt.const 1910423126
      %felt_const_1099252725 = felt.const 1099252725
      %felt_const_1584033957 = felt.const 1584033957
      %felt_const_1079030649 = felt.const 1079030649
      %felt_const_1622328571 = felt.const 1622328571
      %felt_const_1908416316 = felt.const 1908416316
      %felt_const_1549062383 = felt.const 1549062383
      %felt_const_623051854 = felt.const 623051854
      %felt_const_162510541 = felt.const 162510541
      %felt_const_1608853840 = felt.const 1608853840
      %felt_const_538103555 = felt.const 538103555
      %felt_const_1424297384 = felt.const 1424297384
      %felt_const_552696906 = felt.const 552696906
      %felt_const_946500736 = felt.const 946500736
      %felt_const_1215259350 = felt.const 1215259350
      %felt_const_855276054 = felt.const 855276054
      %felt_const_1664590951 = felt.const 1664590951
      %felt_const_217046702 = felt.const 217046702
      %felt_const_142102402 = felt.const 142102402
      %felt_const_1257820264 = felt.const 1257820264
      %felt_const_27129487 = felt.const 27129487
      %felt_const_1147522062 = felt.const 1147522062
      %felt_const_989176635 = felt.const 989176635
      %felt_const_241306552 = felt.const 241306552
      %felt_const_1507936940 = felt.const 1507936940
      %felt_const_1687379185 = felt.const 1687379185
      %felt_const_1150912935 = felt.const 1150912935
      %felt_const_1917549072 = felt.const 1917549072
      %felt_const_1201063290 = felt.const 1201063290
      %felt_const_395622276 = felt.const 395622276
      %felt_const_1997503974 = felt.const 1997503974
      %felt_const_716894289 = felt.const 716894289
      %felt_const_897025192 = felt.const 897025192
      %felt_const_1282239129 = felt.const 1282239129
      %felt_const_1737016378 = felt.const 1737016378
      %felt_const_686842369 = felt.const 686842369
      %felt_const_622609176 = felt.const 622609176
      %felt_const_1339793538 = felt.const 1339793538
      %felt_const_1518763784 = felt.const 1518763784
      %felt_const_1989924532 = felt.const 1989924532
      %felt_const_1170029417 = felt.const 1170029417
      %felt_const_1917861751 = felt.const 1917861751
      %felt_const_1333667262 = felt.const 1333667262
      %felt_const_540703332 = felt.const 540703332
      %felt_const_1845603984 = felt.const 1845603984
      %felt_const_695835963 = felt.const 695835963
      %felt_const_831813382 = felt.const 831813382
      %felt_const_1421525369 = felt.const 1421525369
      %felt_const_1751797115 = felt.const 1751797115
      %felt_const_1964135730 = felt.const 1964135730
      %felt_const_525458520 = felt.const 525458520
      %felt_const_638242172 = felt.const 638242172
      %felt_const_1307439985 = felt.const 1307439985
      %felt_const_343354132 = felt.const 343354132
      %felt_const_1389166148 = felt.const 1389166148
      %felt_const_1660766320 = felt.const 1660766320
      %felt_const_1464793095 = felt.const 1464793095
      %felt_const_1180307149 = felt.const 1180307149
      %felt_const_1930780904 = felt.const 1930780904
      %felt_const_1066694495 = felt.const 1066694495
      %felt_const_1773108264 = felt.const 1773108264
      %felt_const_1004040026 = felt.const 1004040026
      %felt_const_815798990 = felt.const 815798990
      %felt_const_454905424 = felt.const 454905424
      %felt_const_118043943 = felt.const 118043943
      %felt_const_157582794 = felt.const 157582794
      %felt_const_246143118 = felt.const 246143118
      %felt_const_314968988 = felt.const 314968988
      %felt_const_127253399 = felt.const 127253399
      %felt_const_262278199 = felt.const 262278199
      %self = struct.new : !struct.type<@ExtRoundConstants<[]>>
      %array = array.new %felt_const_262278199, %felt_const_127253399, %felt_const_314968988, %felt_const_246143118, %felt_const_157582794, %felt_const_118043943, %felt_const_454905424, %felt_const_815798990, %felt_const_1004040026, %felt_const_1773108264, %felt_const_1066694495, %felt_const_1930780904, %felt_const_1180307149, %felt_const_1464793095, %felt_const_1660766320, %felt_const_1389166148, %felt_const_343354132, %felt_const_1307439985, %felt_const_638242172, %felt_const_525458520, %felt_const_1964135730, %felt_const_1751797115, %felt_const_1421525369, %felt_const_831813382 : <24 x !felt.type>
      %array_0 = array.new %felt_const_695835963, %felt_const_1845603984, %felt_const_540703332, %felt_const_1333667262, %felt_const_1917861751, %felt_const_1170029417, %felt_const_1989924532, %felt_const_1518763784, %felt_const_1339793538, %felt_const_622609176, %felt_const_686842369, %felt_const_1737016378, %felt_const_1282239129, %felt_const_897025192, %felt_const_716894289, %felt_const_1997503974, %felt_const_395622276, %felt_const_1201063290, %felt_const_1917549072, %felt_const_1150912935, %felt_const_1687379185, %felt_const_1507936940, %felt_const_241306552, %felt_const_989176635 : <24 x !felt.type>
      %array_1 = array.new %felt_const_1147522062, %felt_const_27129487, %felt_const_1257820264, %felt_const_142102402, %felt_const_217046702, %felt_const_1664590951, %felt_const_855276054, %felt_const_1215259350, %felt_const_946500736, %felt_const_552696906, %felt_const_1424297384, %felt_const_538103555, %felt_const_1608853840, %felt_const_162510541, %felt_const_623051854, %felt_const_1549062383, %felt_const_1908416316, %felt_const_1622328571, %felt_const_1079030649, %felt_const_1584033957, %felt_const_1099252725, %felt_const_1910423126, %felt_const_447555988, %felt_const_862495875 : <24 x !felt.type>
      %array_2 = array.new %felt_const_128479034, %felt_const_1587822577, %felt_const_608401422, %felt_const_1290028279, %felt_const_342857858, %felt_const_825405577, %felt_const_427731030, %felt_const_1718628547, %felt_const_588764636, %felt_const_204228775, %felt_const_1454563174, %felt_const_1740472809, %felt_const_1338899225, %felt_const_1269493554, %felt_const_53007114, %felt_const_1647670797, %felt_const_306391314, %felt_const_172614232, %felt_const_51256176, %felt_const_1221257987, %felt_const_1239734761, %felt_const_273790406, %felt_const_1781980094, %felt_const_1291790245 : <24 x !felt.type>
      %array_3 = array.new %felt_const_53041581, %felt_const_723038058, %felt_const_1439947916, %felt_const_1136469704, %felt_const_205609311, %felt_const_1883820770, %felt_const_14387587, %felt_const_720724951, %felt_const_1854174607, %felt_const_1629316321, %felt_const_530151394, %felt_const_1679178250, %felt_const_1549779579, %felt_const_48375137, %felt_const_976057819, %felt_const_463976218, %felt_const_875839332, %felt_const_1946596189, %felt_const_434078361, %felt_const_1878280202, %felt_const_1363837384, %felt_const_1470845646, %felt_const_1792450386, %felt_const_1040977421 : <24 x !felt.type>
      %array_4 = array.new %felt_const_1209164052, %felt_const_714957516, %felt_const_390340387, %felt_const_1213686459, %felt_const_790726260, %felt_const_117294666, %felt_const_140621810, %felt_const_993455846, %felt_const_1889603648, %felt_const_78845751, %felt_const_925018226, %felt_const_708123747, %felt_const_1647665372, %felt_const_1649953458, %felt_const_942439428, %felt_const_1006235079, %felt_const_238616145, %felt_const_930036496, %felt_const_1401020792, %felt_const_989618631, %felt_const_1545325389, %felt_const_1715719711, %felt_const_755691969, %felt_const_150307788 : <24 x !felt.type>
      %array_5 = array.new %felt_const_1567618575, %felt_const_1663353317, %felt_const_1950429111, %felt_const_1891637550, %felt_const_192082241, %felt_const_1080533265, %felt_const_1463323727, %felt_const_890243564, %felt_const_158646617, %felt_const_1402624179, %felt_const_59510015, %felt_const_1198261138, %felt_const_1065075039, %felt_const_1150410028, %felt_const_1293938517, %felt_const_76770019, %felt_const_1478577620, %felt_const_1748789933, %felt_const_457372011, %felt_const_1841795381, %felt_const_760115692, %felt_const_1042892522, %felt_const_1507649755, %felt_const_1827572010 : <24 x !felt.type>
      %array_6 = array.new %felt_const_1206940496, %felt_const_1896271507, %felt_const_1003792297, %felt_const_738091882, %felt_const_1124078057, %felt_const_1889898, %felt_const_813674331, %felt_const_228520958, %felt_const_1832911930, %felt_const_781141772, %felt_const_459826664, %felt_const_202271745, %felt_const_1296144415, %felt_const_1111203133, %felt_const_1090783436, %felt_const_641665156, %felt_const_1393671120, %felt_const_1303271640, %felt_const_809508074, %felt_const_162506101, %felt_const_1262312258, %felt_const_1672219447, %felt_const_1608891156, %felt_const_1380248020 : <24 x !felt.type>
      %array_7 = array.new  : <8,24 x !felt.type>
      array.insert %array_7[%c0] = %array : <8,24 x !felt.type>, <24 x !felt.type>
      array.insert %array_7[%c1] = %array_0 : <8,24 x !felt.type>, <24 x !felt.type>
      array.insert %array_7[%c2] = %array_1 : <8,24 x !felt.type>, <24 x !felt.type>
      array.insert %array_7[%c3] = %array_2 : <8,24 x !felt.type>, <24 x !felt.type>
      array.insert %array_7[%c4] = %array_3 : <8,24 x !felt.type>, <24 x !felt.type>
      array.insert %array_7[%c5] = %array_4 : <8,24 x !felt.type>, <24 x !felt.type>
      array.insert %array_7[%c6] = %array_5 : <8,24 x !felt.type>, <24 x !felt.type>
      array.insert %array_7[%c7] = %array_6 : <8,24 x !felt.type>, <24 x !felt.type>
      struct.writef %self[@"$super"] = %array_7 : <@ExtRoundConstants<[]>>, !array.type<8,24 x !felt.type>
      function.return %self : !struct.type<@ExtRoundConstants<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@ExtRoundConstants<[]>>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @DoExtRound<[]> {
    struct.field @"$super" : !struct.type<@MultiplyByMExt<[]>>
    struct.field @"$temp_0" : !struct.type<@MultiplyByMExt<[]>>
    struct.field @"$temp" : !array.type<24 x !struct.type<@SBox<[]>>> {column}
    struct.field @"$array" : !array.type<24 x !struct.type<@SBox<[]>>> {column}
    function.def @compute(%arg0: !array.type<24 x !felt.type>, %arg1: !array.type<24 x !felt.type>) -> !struct.type<@DoExtRound<[]>> attributes {function.allow_witness} {
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@DoExtRound<[]>>
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !struct.type<@SBox<[]>>>
      scf.for %arg2 = %c0 to %c24 step %c1 {
        %4 = array.read %array[%arg2] : <24 x !felt.type>, !felt.type
        %5 = cast.toindex %4
        %6 = array.read %arg0[%5] : <24 x !felt.type>, !felt.type
        %7 = cast.toindex %4
        %8 = array.read %arg1[%7] : <24 x !felt.type>, !felt.type
        %9 = felt.add %6, %8 : !felt.type, !felt.type
        %10 = function.call @SBox::@compute(%9) : (!felt.type) -> !struct.type<@SBox<[]>>
        %11 = struct.readf %self[@"$temp"] : <@DoExtRound<[]>>, !array.type<24 x !struct.type<@SBox<[]>>>
        array.write %11[%arg2] = %10 : <24 x !struct.type<@SBox<[]>>>, !struct.type<@SBox<[]>>
        struct.writef %self[@"$temp"] = %11 : <@DoExtRound<[]>>, !array.type<24 x !struct.type<@SBox<[]>>>
        %12 = struct.readf %self[@"$temp"] : <@DoExtRound<[]>>, !array.type<24 x !struct.type<@SBox<[]>>>
        %13 = array.read %12[%arg2] : <24 x !struct.type<@SBox<[]>>>, !struct.type<@SBox<[]>>
        array.write %array_0[%arg2] = %13 : <24 x !struct.type<@SBox<[]>>>, !struct.type<@SBox<[]>>
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_0 : <@DoExtRound<[]>>, !array.type<24 x !struct.type<@SBox<[]>>>
      %0 = struct.readf %self[@"$array"] : <@DoExtRound<[]>>, !array.type<24 x !struct.type<@SBox<[]>>>
      %array_1 = array.new  : <24 x !felt.type>
      %1 = array.len %0, %c0 : <24 x !struct.type<@SBox<[]>>>
      scf.for %arg2 = %c0 to %c1 step %1 {
        %4 = array.read %0[%arg2] : <24 x !struct.type<@SBox<[]>>>, !struct.type<@SBox<[]>>
        %5 = struct.readf %4[@"$super"] : <@SBox<[]>>, !struct.type<@Reg<[]>>
        %6 = struct.readf %5[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %7 = struct.readf %6[@"$super"] : <@NondetReg<[]>>, !felt.type
        array.write %array_1[%arg2] = %7 : <24 x !felt.type>, !felt.type
      }
      %2 = function.call @MultiplyByMExt::@compute(%array_1) : (!array.type<24 x !felt.type>) -> !struct.type<@MultiplyByMExt<[]>>
      struct.writef %self[@"$temp_0"] = %2 : <@DoExtRound<[]>>, !struct.type<@MultiplyByMExt<[]>>
      %3 = struct.readf %self[@"$temp_0"] : <@DoExtRound<[]>>, !struct.type<@MultiplyByMExt<[]>>
      struct.writef %self[@"$super"] = %3 : <@DoExtRound<[]>>, !struct.type<@MultiplyByMExt<[]>>
      function.return %self : !struct.type<@DoExtRound<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@DoExtRound<[]>>, %arg1: !array.type<24 x !felt.type>, %arg2: !array.type<24 x !felt.type>) attributes {function.allow_constraint} {
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_0 = felt.const 0
      %felt_const_1 = felt.const 1
      %felt_const_2 = felt.const 2
      %felt_const_3 = felt.const 3
      %felt_const_4 = felt.const 4
      %felt_const_5 = felt.const 5
      %felt_const_6 = felt.const 6
      %felt_const_7 = felt.const 7
      %felt_const_8 = felt.const 8
      %felt_const_9 = felt.const 9
      %felt_const_10 = felt.const 10
      %felt_const_11 = felt.const 11
      %felt_const_12 = felt.const 12
      %felt_const_13 = felt.const 13
      %felt_const_14 = felt.const 14
      %felt_const_15 = felt.const 15
      %felt_const_16 = felt.const 16
      %felt_const_17 = felt.const 17
      %felt_const_18 = felt.const 18
      %felt_const_19 = felt.const 19
      %felt_const_20 = felt.const 20
      %felt_const_21 = felt.const 21
      %felt_const_22 = felt.const 22
      %felt_const_23 = felt.const 23
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !struct.type<@SBox<[]>>>
      scf.for %arg3 = %c0 to %c24 step %c1 {
        %3 = array.read %array[%arg3] : <24 x !felt.type>, !felt.type
        %4 = cast.toindex %3
        %5 = array.read %arg1[%4] : <24 x !felt.type>, !felt.type
        %6 = cast.toindex %3
        %7 = array.read %arg2[%6] : <24 x !felt.type>, !felt.type
        %8 = felt.add %5, %7 : !felt.type, !felt.type
        %9 = struct.readf %arg0[@"$temp"] : <@DoExtRound<[]>>, !array.type<24 x !struct.type<@SBox<[]>>>
        %10 = struct.readf %arg0[@"$temp"] : <@DoExtRound<[]>>, !array.type<24 x !struct.type<@SBox<[]>>>
        %11 = array.read %10[%arg3] : <24 x !struct.type<@SBox<[]>>>, !struct.type<@SBox<[]>>
        function.call @SBox::@constrain(%11, %8) : (!struct.type<@SBox<[]>>, !felt.type) -> ()
        array.write %array_0[%arg3] = %11 : <24 x !struct.type<@SBox<[]>>>, !struct.type<@SBox<[]>>
      } {original_op = "map"}
      %0 = struct.readf %arg0[@"$array"] : <@DoExtRound<[]>>, !array.type<24 x !struct.type<@SBox<[]>>>
      %array_1 = array.new  : <24 x !felt.type>
      %1 = array.len %0, %c0 : <24 x !struct.type<@SBox<[]>>>
      scf.for %arg3 = %c0 to %c1 step %1 {
        %3 = array.read %0[%arg3] : <24 x !struct.type<@SBox<[]>>>, !struct.type<@SBox<[]>>
        %4 = struct.readf %3[@"$super"] : <@SBox<[]>>, !struct.type<@Reg<[]>>
        %5 = struct.readf %4[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %6 = struct.readf %5[@"$super"] : <@NondetReg<[]>>, !felt.type
        array.write %array_1[%arg3] = %6 : <24 x !felt.type>, !felt.type
      }
      %2 = struct.readf %arg0[@"$temp_0"] : <@DoExtRound<[]>>, !struct.type<@MultiplyByMExt<[]>>
      function.call @MultiplyByMExt::@constrain(%2, %array_1) : (!struct.type<@MultiplyByMExt<[]>>, !array.type<24 x !felt.type>) -> ()
      function.return
    }
  }
  struct.def @AddConsts<[]> {
    struct.field @"$super" : !array.type<24 x !felt.type>
    struct.field @"$array" : !array.type<24 x !felt.type>
    function.def @compute(%arg0: !array.type<24 x !felt.type>, %arg1: !array.type<24 x !felt.type>) -> !struct.type<@AddConsts<[]>> attributes {function.allow_witness} {
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@AddConsts<[]>>
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !felt.type>
      scf.for %arg2 = %c0 to %c24 step %c1 {
        %1 = array.read %array[%arg2] : <24 x !felt.type>, !felt.type
        %2 = cast.toindex %1
        %3 = array.read %arg0[%2] : <24 x !felt.type>, !felt.type
        %4 = cast.toindex %1
        %5 = array.read %arg1[%4] : <24 x !felt.type>, !felt.type
        %6 = felt.add %3, %5 : !felt.type, !felt.type
        array.write %array_0[%arg2] = %6 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_0 : <@AddConsts<[]>>, !array.type<24 x !felt.type>
      %0 = struct.readf %self[@"$array"] : <@AddConsts<[]>>, !array.type<24 x !felt.type>
      struct.writef %self[@"$super"] = %0 : <@AddConsts<[]>>, !array.type<24 x !felt.type>
      function.return %self : !struct.type<@AddConsts<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@AddConsts<[]>>, %arg1: !array.type<24 x !felt.type>, %arg2: !array.type<24 x !felt.type>) attributes {function.allow_constraint} {
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_0 = felt.const 0
      %felt_const_1 = felt.const 1
      %felt_const_2 = felt.const 2
      %felt_const_3 = felt.const 3
      %felt_const_4 = felt.const 4
      %felt_const_5 = felt.const 5
      %felt_const_6 = felt.const 6
      %felt_const_7 = felt.const 7
      %felt_const_8 = felt.const 8
      %felt_const_9 = felt.const 9
      %felt_const_10 = felt.const 10
      %felt_const_11 = felt.const 11
      %felt_const_12 = felt.const 12
      %felt_const_13 = felt.const 13
      %felt_const_14 = felt.const 14
      %felt_const_15 = felt.const 15
      %felt_const_16 = felt.const 16
      %felt_const_17 = felt.const 17
      %felt_const_18 = felt.const 18
      %felt_const_19 = felt.const 19
      %felt_const_20 = felt.const 20
      %felt_const_21 = felt.const 21
      %felt_const_22 = felt.const 22
      %felt_const_23 = felt.const 23
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !felt.type>
      scf.for %arg3 = %c0 to %c24 step %c1 {
        %1 = array.read %array[%arg3] : <24 x !felt.type>, !felt.type
        %2 = cast.toindex %1
        %3 = array.read %arg1[%2] : <24 x !felt.type>, !felt.type
        %4 = cast.toindex %1
        %5 = array.read %arg2[%4] : <24 x !felt.type>, !felt.type
        %6 = felt.add %3, %5 : !felt.type, !felt.type
        array.write %array_0[%arg3] = %6 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      %0 = struct.readf %arg0[@"$array"] : <@AddConsts<[]>>, !array.type<24 x !felt.type>
      function.return
    }
  }
  struct.def @MultBy<[]> {
    struct.field @"$super" : !array.type<24 x !felt.type>
    struct.field @"$array" : !array.type<24 x !felt.type>
    function.def @compute(%arg0: !array.type<24 x !felt.type>, %arg1: !felt.type) -> !struct.type<@MultBy<[]>> attributes {function.allow_witness} {
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %self = struct.new : !struct.type<@MultBy<[]>>
      %array = array.new  : <24 x !felt.type>
      scf.for %arg2 = %c0 to %c24 step %c1 {
        %1 = array.read %arg0[%arg2] : <24 x !felt.type>, !felt.type
        %2 = felt.mul %1, %arg1 : !felt.type, !felt.type
        array.write %array[%arg2] = %2 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array : <@MultBy<[]>>, !array.type<24 x !felt.type>
      %0 = struct.readf %self[@"$array"] : <@MultBy<[]>>, !array.type<24 x !felt.type>
      struct.writef %self[@"$super"] = %0 : <@MultBy<[]>>, !array.type<24 x !felt.type>
      function.return %self : !struct.type<@MultBy<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@MultBy<[]>>, %arg1: !array.type<24 x !felt.type>, %arg2: !felt.type) attributes {function.allow_constraint} {
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %array = array.new  : <24 x !felt.type>
      scf.for %arg3 = %c0 to %c24 step %c1 {
        %1 = array.read %arg1[%arg3] : <24 x !felt.type>, !felt.type
        %2 = felt.mul %1, %arg2 : !felt.type, !felt.type
        array.write %array[%arg3] = %2 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      %0 = struct.readf %arg0[@"$array"] : <@MultBy<[]>>, !array.type<24 x !felt.type>
      function.return
    }
  }
  struct.def @DoExtRoundByIdx<[]> {
    struct.field @"$super" : !struct.type<@DoExtRound<[]>>
    struct.field @"$temp_2" : !struct.type<@DoExtRound<[]>>
    struct.field @"$temp_1" : !array.type<8 x !struct.type<@AddConsts<[]>>>
    struct.field @"$temp_0" : !array.type<8 x !struct.type<@MultBy<[]>>>
    struct.field @"$temp" : !array.type<8 x !struct.type<@ExtRoundConstants<[]>>>
    struct.field @"$array" : !array.type<8 x !struct.type<@MultBy<[]>>>
    struct.field @zeroConsts : !array.type<24 x !felt.type>
    struct.field @idxHot : !struct.type<@OneHot<[8]>> {column}
    function.def @compute(%arg0: !array.type<24 x !felt.type>, %arg1: !felt.type) -> !struct.type<@DoExtRoundByIdx<[]>> attributes {function.allow_witness} {
      %c8 = arith.constant 8 : index
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@DoExtRoundByIdx<[]>>
      %0 = function.call @OneHot::@compute(%arg1) : (!felt.type) -> !struct.type<@OneHot<[8]>>
      struct.writef %self[@idxHot] = %0 : <@DoExtRoundByIdx<[]>>, !struct.type<@OneHot<[8]>>
      %1 = struct.readf %self[@idxHot] : <@DoExtRoundByIdx<[]>>, !struct.type<@OneHot<[8]>>
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !felt.type>
      scf.for %arg2 = %c0 to %c24 step %c1 {
        %7 = array.read %array[%arg2] : <24 x !felt.type>, !felt.type
        array.write %array_0[%arg2] = %felt_const_0 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@zeroConsts] = %array_0 : <@DoExtRoundByIdx<[]>>, !array.type<24 x !felt.type>
      %2 = struct.readf %self[@zeroConsts] : <@DoExtRoundByIdx<[]>>, !array.type<24 x !felt.type>
      %array_1 = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7 : <8 x !felt.type>
      %array_2 = array.new  : <8 x !struct.type<@MultBy<[]>>>
      scf.for %arg2 = %c0 to %c8 step %c1 {
        %7 = array.read %array_1[%arg2] : <8 x !felt.type>, !felt.type
        %8 = function.call @ExtRoundConstants::@compute() : () -> !struct.type<@ExtRoundConstants<[]>>
        %9 = struct.readf %self[@"$temp"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@ExtRoundConstants<[]>>>
        array.write %9[%arg2] = %8 : <8 x !struct.type<@ExtRoundConstants<[]>>>, !struct.type<@ExtRoundConstants<[]>>
        struct.writef %self[@"$temp"] = %9 : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@ExtRoundConstants<[]>>>
        %10 = struct.readf %self[@"$temp"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@ExtRoundConstants<[]>>>
        %11 = array.read %10[%arg2] : <8 x !struct.type<@ExtRoundConstants<[]>>>, !struct.type<@ExtRoundConstants<[]>>
        %12 = struct.readf %11[@"$super"] : <@ExtRoundConstants<[]>>, !array.type<8,24 x !felt.type>
        %13 = cast.toindex %7
        %14 = array.extract %12[%13] : <8,24 x !felt.type>
        %15 = struct.readf %1[@bits] : <@OneHot<[8]>>, !array.type<8 x !struct.type<@NondetBitReg<[]>>>
        %16 = cast.toindex %7
        %17 = array.read %15[%16] : <8 x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
        %18 = struct.readf %17[@"$super"] : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
        %19 = struct.readf %18[@"$super"] : <@NondetReg<[]>>, !felt.type
        %20 = function.call @MultBy::@compute(%14, %19) : (!array.type<24 x !felt.type>, !felt.type) -> !struct.type<@MultBy<[]>>
        %21 = struct.readf %self[@"$temp_0"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@MultBy<[]>>>
        array.write %21[%arg2] = %20 : <8 x !struct.type<@MultBy<[]>>>, !struct.type<@MultBy<[]>>
        struct.writef %self[@"$temp_0"] = %21 : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@MultBy<[]>>>
        %22 = struct.readf %self[@"$temp_0"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@MultBy<[]>>>
        %23 = array.read %22[%arg2] : <8 x !struct.type<@MultBy<[]>>>, !struct.type<@MultBy<[]>>
        array.write %array_2[%arg2] = %23 : <8 x !struct.type<@MultBy<[]>>>, !struct.type<@MultBy<[]>>
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_2 : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@MultBy<[]>>>
      %3 = struct.readf %self[@"$array"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@MultBy<[]>>>
      %4 = scf.for %arg2 = %c0 to %c8 step %c1 iter_args(%arg3 = %2) -> (!array.type<24 x !felt.type>) {
        %7 = array.read %3[%arg2] : <8 x !struct.type<@MultBy<[]>>>, !struct.type<@MultBy<[]>>
        %8 = struct.readf %7[@"$super"] : <@MultBy<[]>>, !array.type<24 x !felt.type>
        %9 = poly.unifiable_cast %8 : (!array.type<24 x !felt.type>) -> !array.type<24 x !felt.type>
        %10 = function.call @AddConsts::@compute(%arg3, %9) : (!array.type<24 x !felt.type>, !array.type<24 x !felt.type>) -> !struct.type<@AddConsts<[]>>
        %11 = struct.readf %self[@"$temp_1"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@AddConsts<[]>>>
        array.write %11[%arg2] = %10 : <8 x !struct.type<@AddConsts<[]>>>, !struct.type<@AddConsts<[]>>
        struct.writef %self[@"$temp_1"] = %11 : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@AddConsts<[]>>>
        %12 = struct.readf %self[@"$temp_1"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@AddConsts<[]>>>
        %13 = array.read %12[%arg2] : <8 x !struct.type<@AddConsts<[]>>>, !struct.type<@AddConsts<[]>>
        %14 = struct.readf %13[@"$super"] : <@AddConsts<[]>>, !array.type<24 x !felt.type>
        %15 = poly.unifiable_cast %14 : (!array.type<24 x !felt.type>) -> !array.type<24 x !felt.type>
        scf.yield %15 : !array.type<24 x !felt.type>
      } {original_op = "reduce"}
      %5 = function.call @DoExtRound::@compute(%arg0, %4) : (!array.type<24 x !felt.type>, !array.type<24 x !felt.type>) -> !struct.type<@DoExtRound<[]>>
      struct.writef %self[@"$temp_2"] = %5 : <@DoExtRoundByIdx<[]>>, !struct.type<@DoExtRound<[]>>
      %6 = struct.readf %self[@"$temp_2"] : <@DoExtRoundByIdx<[]>>, !struct.type<@DoExtRound<[]>>
      struct.writef %self[@"$super"] = %6 : <@DoExtRoundByIdx<[]>>, !struct.type<@DoExtRound<[]>>
      function.return %self : !struct.type<@DoExtRoundByIdx<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@DoExtRoundByIdx<[]>>, %arg1: !array.type<24 x !felt.type>, %arg2: !felt.type) attributes {function.allow_constraint} {
      %c8 = arith.constant 8 : index
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %0 = struct.readf %arg0[@idxHot] : <@DoExtRoundByIdx<[]>>, !struct.type<@OneHot<[8]>>
      function.call @OneHot::@constrain(%0, %arg2) : (!struct.type<@OneHot<[8]>>, !felt.type) -> ()
      %array = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_0 = array.new  : <24 x !felt.type>
      scf.for %arg3 = %c0 to %c24 step %c1 {
        %5 = array.read %array[%arg3] : <24 x !felt.type>, !felt.type
        array.write %array_0[%arg3] = %felt_const_0 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      %1 = struct.readf %arg0[@zeroConsts] : <@DoExtRoundByIdx<[]>>, !array.type<24 x !felt.type>
      %array_1 = array.new %felt_const_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7 : <8 x !felt.type>
      %array_2 = array.new  : <8 x !struct.type<@MultBy<[]>>>
      scf.for %arg3 = %c0 to %c8 step %c1 {
        %5 = array.read %array_1[%arg3] : <8 x !felt.type>, !felt.type
        %6 = struct.readf %arg0[@"$temp"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@ExtRoundConstants<[]>>>
        %7 = struct.readf %arg0[@"$temp"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@ExtRoundConstants<[]>>>
        %8 = array.read %7[%arg3] : <8 x !struct.type<@ExtRoundConstants<[]>>>, !struct.type<@ExtRoundConstants<[]>>
        function.call @ExtRoundConstants::@constrain(%8) : (!struct.type<@ExtRoundConstants<[]>>) -> ()
        %9 = struct.readf %8[@"$super"] : <@ExtRoundConstants<[]>>, !array.type<8,24 x !felt.type>
        %10 = cast.toindex %5
        %11 = array.extract %9[%10] : <8,24 x !felt.type>
        %12 = struct.readf %0[@bits] : <@OneHot<[8]>>, !array.type<8 x !struct.type<@NondetBitReg<[]>>>
        %13 = cast.toindex %5
        %14 = array.read %12[%13] : <8 x !struct.type<@NondetBitReg<[]>>>, !struct.type<@NondetBitReg<[]>>
        %15 = struct.readf %14[@"$super"] : <@NondetBitReg<[]>>, !struct.type<@NondetReg<[]>>
        %16 = struct.readf %15[@"$super"] : <@NondetReg<[]>>, !felt.type
        %17 = struct.readf %arg0[@"$temp_0"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@MultBy<[]>>>
        %18 = struct.readf %arg0[@"$temp_0"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@MultBy<[]>>>
        %19 = array.read %18[%arg3] : <8 x !struct.type<@MultBy<[]>>>, !struct.type<@MultBy<[]>>
        function.call @MultBy::@constrain(%19, %11, %16) : (!struct.type<@MultBy<[]>>, !array.type<24 x !felt.type>, !felt.type) -> ()
        array.write %array_2[%arg3] = %19 : <8 x !struct.type<@MultBy<[]>>>, !struct.type<@MultBy<[]>>
      } {original_op = "map"}
      %2 = struct.readf %arg0[@"$array"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@MultBy<[]>>>
      %3 = scf.for %arg3 = %c0 to %c8 step %c1 iter_args(%arg4 = %1) -> (!array.type<24 x !felt.type>) {
        %5 = array.read %2[%arg3] : <8 x !struct.type<@MultBy<[]>>>, !struct.type<@MultBy<[]>>
        %6 = struct.readf %5[@"$super"] : <@MultBy<[]>>, !array.type<24 x !felt.type>
        %7 = poly.unifiable_cast %6 : (!array.type<24 x !felt.type>) -> !array.type<24 x !felt.type>
        %8 = struct.readf %arg0[@"$temp_1"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@AddConsts<[]>>>
        %9 = struct.readf %arg0[@"$temp_1"] : <@DoExtRoundByIdx<[]>>, !array.type<8 x !struct.type<@AddConsts<[]>>>
        %10 = array.read %9[%arg3] : <8 x !struct.type<@AddConsts<[]>>>, !struct.type<@AddConsts<[]>>
        function.call @AddConsts::@constrain(%10, %arg4, %7) : (!struct.type<@AddConsts<[]>>, !array.type<24 x !felt.type>, !array.type<24 x !felt.type>) -> ()
        %11 = struct.readf %10[@"$super"] : <@AddConsts<[]>>, !array.type<24 x !felt.type>
        %12 = poly.unifiable_cast %11 : (!array.type<24 x !felt.type>) -> !array.type<24 x !felt.type>
        scf.yield %12 : !array.type<24 x !felt.type>
      } {original_op = "reduce"}
      %4 = struct.readf %arg0[@"$temp_2"] : <@DoExtRoundByIdx<[]>>, !struct.type<@DoExtRound<[]>>
      function.call @DoExtRound::@constrain(%4, %arg1, %3) : (!struct.type<@DoExtRound<[]>>, !array.type<24 x !felt.type>, !array.type<24 x !felt.type>) -> ()
      function.return
    }
  }
  struct.def @Pegs<[@N]> {
    struct.field @"$super" : !array.type<@N x !struct.type<@Reg<[]>>>
    struct.field @"$temp" : !array.type<@N x !struct.type<@Reg<[]>>> {column}
    struct.field @"$array" : !array.type<@N x !struct.type<@Reg<[]>>> {column}
    function.def @compute(%arg0: !array.type<@N x !felt.type>) -> !struct.type<@Pegs<[@N]>> attributes {function.allow_witness} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %self = struct.new : !struct.type<@Pegs<[@N]>>
      %array = array.new  : <@N x !struct.type<@Reg<[]>>>
      %0 = array.len %arg0, %c0 : <@N x !felt.type>
      scf.for %arg1 = %c0 to %0 step %c1 {
        %2 = array.read %arg0[%arg1] : <@N x !felt.type>, !felt.type
        %3 = function.call @Reg::@compute(%2) : (!felt.type) -> !struct.type<@Reg<[]>>
        %4 = struct.readf %self[@"$temp"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
        array.write %4[%arg1] = %3 : <@N x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        struct.writef %self[@"$temp"] = %4 : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
        %5 = struct.readf %self[@"$temp"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
        %6 = array.read %5[%arg1] : <@N x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        array.write %array[%arg1] = %6 : <@N x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
      %1 = struct.readf %self[@"$array"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
      struct.writef %self[@"$super"] = %1 : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
      function.return %self : !struct.type<@Pegs<[@N]>>
    }
    function.def @constrain(%arg0: !struct.type<@Pegs<[@N]>>, %arg1: !array.type<@N x !felt.type>) attributes {function.allow_constraint} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %array = array.new  : <@N x !struct.type<@Reg<[]>>>
      %0 = array.len %arg1, %c0 : <@N x !felt.type>
      scf.for %arg2 = %c0 to %0 step %c1 {
        %2 = array.read %arg1[%arg2] : <@N x !felt.type>, !felt.type
        %3 = struct.readf %arg0[@"$temp"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
        %4 = struct.readf %arg0[@"$temp"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
        %5 = array.read %4[%arg2] : <@N x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        function.call @Reg::@constrain(%5, %2) : (!struct.type<@Reg<[]>>, !felt.type) -> ()
        array.write %array[%arg2] = %5 : <@N x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
      } {original_op = "map"}
      %1 = struct.readf %arg0[@"$array"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
      function.return
    }
  }
  struct.def @Nonce<[]> {
    struct.field @"$super" : !struct.type<@Reg<[]>>
    struct.field @"$temp" : !struct.type<@Reg<[]>> {column}
    function.def @compute(%arg0: !felt.type) -> !struct.type<@Nonce<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Nonce<[]>>
      %0 = function.call @Reg::@compute(%arg0) : (!felt.type) -> !struct.type<@Reg<[]>>
      struct.writef %self[@"$temp"] = %0 : <@Nonce<[]>>, !struct.type<@Reg<[]>>
      %1 = struct.readf %self[@"$temp"] : <@Nonce<[]>>, !struct.type<@Reg<[]>>
      struct.writef %self[@"$super"] = %1 : <@Nonce<[]>>, !struct.type<@Reg<[]>>
      function.return %self : !struct.type<@Nonce<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Nonce<[]>>, %arg1: !felt.type) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@"$temp"] : <@Nonce<[]>>, !struct.type<@Reg<[]>>
      function.call @Reg::@constrain(%0, %arg1) : (!struct.type<@Reg<[]>>, !felt.type) -> ()
      function.return
    }
  }
  struct.def @IsZero<[]> {
    struct.field @"$super" : !struct.type<@NondetReg<[]>>
    struct.field @"$temp_0" : !struct.type<@AssertBit<[]>>
    struct.field @inv : !struct.type<@NondetReg<[]>> {column}
    struct.field @"$temp" : !felt.type
    struct.field @isZero : !struct.type<@NondetReg<[]>> {column}
    function.def @compute(%arg0: !felt.type) -> !struct.type<@IsZero<[]>> attributes {function.allow_witness} {
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@IsZero<[]>>
      %0 = bool.cmp eq(%arg0, %felt_const_0)
      %1 = cast.tofelt %0 : i1
      %2 = function.call @NondetReg::@compute(%1) : (!felt.type) -> !struct.type<@NondetReg<[]>>
      struct.writef %self[@isZero] = %2 : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
      %3 = struct.readf %self[@isZero] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
      %4 = felt.inv %arg0 : !felt.type
      struct.writef %self[@"$temp"] = %4 : <@IsZero<[]>>, !felt.type
      %5 = struct.readf %self[@"$temp"] : <@IsZero<[]>>, !felt.type
      %6 = function.call @NondetReg::@compute(%5) : (!felt.type) -> !struct.type<@NondetReg<[]>>
      struct.writef %self[@inv] = %6 : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
      %7 = struct.readf %self[@inv] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
      %8 = struct.readf %3[@"$super"] : <@NondetReg<[]>>, !felt.type
      %9 = function.call @AssertBit::@compute(%8) : (!felt.type) -> !struct.type<@AssertBit<[]>>
      struct.writef %self[@"$temp_0"] = %9 : <@IsZero<[]>>, !struct.type<@AssertBit<[]>>
      %10 = struct.readf %self[@"$temp_0"] : <@IsZero<[]>>, !struct.type<@AssertBit<[]>>
      %11 = struct.readf %7[@"$super"] : <@NondetReg<[]>>, !felt.type
      %12 = struct.readf %3[@"$super"] : <@NondetReg<[]>>, !felt.type
      %13 = struct.readf %3[@"$super"] : <@NondetReg<[]>>, !felt.type
      %14 = struct.readf %3[@"$super"] : <@NondetReg<[]>>, !felt.type
      %15 = struct.readf %7[@"$super"] : <@NondetReg<[]>>, !felt.type
      struct.writef %self[@"$super"] = %3 : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
      function.return %self : !struct.type<@IsZero<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@IsZero<[]>>, %arg1: !felt.type) attributes {function.allow_constraint} {
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %0 = bool.cmp eq(%arg1, %felt_const_0)
      %1 = cast.tofelt %0 : i1
      %2 = struct.readf %arg0[@isZero] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
      function.call @NondetReg::@constrain(%2, %1) : (!struct.type<@NondetReg<[]>>, !felt.type) -> ()
      %3 = struct.readf %arg0[@"$temp"] : <@IsZero<[]>>, !felt.type
      %4 = struct.readf %arg0[@inv] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
      function.call @NondetReg::@constrain(%4, %3) : (!struct.type<@NondetReg<[]>>, !felt.type) -> ()
      %5 = struct.readf %2[@"$super"] : <@NondetReg<[]>>, !felt.type
      %6 = struct.readf %arg0[@"$temp_0"] : <@IsZero<[]>>, !struct.type<@AssertBit<[]>>
      function.call @AssertBit::@constrain(%6, %5) : (!struct.type<@AssertBit<[]>>, !felt.type) -> ()
      %7 = struct.readf %4[@"$super"] : <@NondetReg<[]>>, !felt.type
      %8 = felt.mul %arg1, %7 : !felt.type, !felt.type
      %9 = struct.readf %2[@"$super"] : <@NondetReg<[]>>, !felt.type
      %10 = felt.sub %felt_const_1, %9 : !felt.type, !felt.type
      constrain.eq %8, %10 : !felt.type, !felt.type
      %11 = struct.readf %2[@"$super"] : <@NondetReg<[]>>, !felt.type
      %12 = felt.mul %11, %arg1 : !felt.type, !felt.type
      constrain.eq %12, %felt_const_0 : !felt.type, !felt.type
      %13 = struct.readf %2[@"$super"] : <@NondetReg<[]>>, !felt.type
      %14 = struct.readf %4[@"$super"] : <@NondetReg<[]>>, !felt.type
      %15 = felt.mul %13, %14 : !felt.type, !felt.type
      constrain.eq %15, %felt_const_0 : !felt.type, !felt.type
      function.return
    }
  }
  struct.def @Eq<[]> {
    struct.field @"$super" : !struct.type<@IsZero<[]>>
    struct.field @"$temp" : !struct.type<@IsZero<[]>> {column}
    function.def @compute(%arg0: !felt.type, %arg1: !felt.type) -> !struct.type<@Eq<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Eq<[]>>
      %0 = felt.sub %arg0, %arg1 : !felt.type, !felt.type
      %1 = function.call @IsZero::@compute(%0) : (!felt.type) -> !struct.type<@IsZero<[]>>
      struct.writef %self[@"$temp"] = %1 : <@Eq<[]>>, !struct.type<@IsZero<[]>>
      %2 = struct.readf %self[@"$temp"] : <@Eq<[]>>, !struct.type<@IsZero<[]>>
      struct.writef %self[@"$super"] = %2 : <@Eq<[]>>, !struct.type<@IsZero<[]>>
      function.return %self : !struct.type<@Eq<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Eq<[]>>, %arg1: !felt.type, %arg2: !felt.type) attributes {function.allow_constraint} {
      %0 = felt.sub %arg1, %arg2 : !felt.type, !felt.type
      %1 = struct.readf %arg0[@"$temp"] : <@Eq<[]>>, !struct.type<@IsZero<[]>>
      function.call @IsZero::@constrain(%1, %0) : (!struct.type<@IsZero<[]>>, !felt.type) -> ()
      function.return
    }
  }
  struct.def @EnsureEq<[@T]> {
    struct.field @"$super" : !struct.type<@Eq<[]>>
    struct.field @"$temp" : !struct.type<@Assert<[]>>
    struct.field @r : !struct.type<@Eq<[]>> {column}
    function.def @compute(%arg0: !poly.tvar<@T>, %arg1: !poly.tvar<@T>) -> !struct.type<@EnsureEq<[@T]>> attributes {function.allow_witness} {
      %0 = string.new "Provided values are not equal"
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@EnsureEq<[@T]>>
      %1 = poly.unifiable_cast %arg0 : (!poly.tvar<@T>) -> !felt.type
      %2 = poly.unifiable_cast %arg1 : (!poly.tvar<@T>) -> !felt.type
      %3 = function.call @Eq::@compute(%1, %2) : (!felt.type, !felt.type) -> !struct.type<@Eq<[]>>
      struct.writef %self[@r] = %3 : <@EnsureEq<[@T]>>, !struct.type<@Eq<[]>>
      %4 = struct.readf %self[@r] : <@EnsureEq<[@T]>>, !struct.type<@Eq<[]>>
      %5 = struct.readf %4[@"$super"] : <@Eq<[]>>, !struct.type<@IsZero<[]>>
      %6 = struct.readf %5[@"$super"] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
      %7 = struct.readf %6[@"$super"] : <@NondetReg<[]>>, !felt.type
      %8 = bool.cmp eq(%7, %felt_const_0)
      %9 = cast.tofelt %8 : i1
      %10 = function.call @Assert::@compute(%9, %0) : (!felt.type, !string.type) -> !struct.type<@Assert<[]>>
      struct.writef %self[@"$temp"] = %10 : <@EnsureEq<[@T]>>, !struct.type<@Assert<[]>>
      %11 = struct.readf %self[@"$temp"] : <@EnsureEq<[@T]>>, !struct.type<@Assert<[]>>
      struct.writef %self[@"$super"] = %4 : <@EnsureEq<[@T]>>, !struct.type<@Eq<[]>>
      function.return %self : !struct.type<@EnsureEq<[@T]>>
    }
    function.def @constrain(%arg0: !struct.type<@EnsureEq<[@T]>>, %arg1: !poly.tvar<@T>, %arg2: !poly.tvar<@T>) attributes {function.allow_constraint} {
      %0 = string.new "Provided values are not equal"
      %felt_const_0 = felt.const 0
      constrain.eq %arg1, %arg2 : !poly.tvar<@T>, !poly.tvar<@T>
      %1 = poly.unifiable_cast %arg1 : (!poly.tvar<@T>) -> !felt.type
      %2 = poly.unifiable_cast %arg2 : (!poly.tvar<@T>) -> !felt.type
      %3 = struct.readf %arg0[@r] : <@EnsureEq<[@T]>>, !struct.type<@Eq<[]>>
      function.call @Eq::@constrain(%3, %1, %2) : (!struct.type<@Eq<[]>>, !felt.type, !felt.type) -> ()
      %4 = struct.readf %3[@"$super"] : <@Eq<[]>>, !struct.type<@IsZero<[]>>
      %5 = struct.readf %4[@"$super"] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
      %6 = struct.readf %5[@"$super"] : <@NondetReg<[]>>, !felt.type
      %7 = bool.cmp eq(%6, %felt_const_0)
      %8 = cast.tofelt %7 : i1
      %9 = struct.readf %arg0[@"$temp"] : <@EnsureEq<[@T]>>, !struct.type<@Assert<[]>>
      function.call @Assert::@constrain(%9, %8, %0) : (!struct.type<@Assert<[]>>, !felt.type, !string.type) -> ()
      function.return
    }
  }
  struct.def @MulReg<[]> {
    struct.field @"$super" : !struct.type<@NondetReg<[]>>
    struct.field @"$temp" : !struct.type<@NondetReg<[]>> {column}
    function.def @compute(%arg0: !struct.type<@NondetReg<[]>>, %arg1: !struct.type<@NondetReg<[]>>) -> !struct.type<@MulReg<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@MulReg<[]>>
      %0 = struct.readf %arg0[@"$super"] : <@NondetReg<[]>>, !felt.type
      %1 = struct.readf %arg1[@"$super"] : <@NondetReg<[]>>, !felt.type
      %2 = felt.mul %0, %1 : !felt.type, !felt.type
      %3 = function.call @NondetReg::@compute(%2) : (!felt.type) -> !struct.type<@NondetReg<[]>>
      struct.writef %self[@"$temp"] = %3 : <@MulReg<[]>>, !struct.type<@NondetReg<[]>>
      %4 = struct.readf %self[@"$temp"] : <@MulReg<[]>>, !struct.type<@NondetReg<[]>>
      struct.writef %self[@"$super"] = %4 : <@MulReg<[]>>, !struct.type<@NondetReg<[]>>
      function.return %self : !struct.type<@MulReg<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@MulReg<[]>>, %arg1: !struct.type<@NondetReg<[]>>, %arg2: !struct.type<@NondetReg<[]>>) attributes {function.allow_constraint} {
      %0 = struct.readf %arg1[@"$super"] : <@NondetReg<[]>>, !felt.type
      %1 = struct.readf %arg2[@"$super"] : <@NondetReg<[]>>, !felt.type
      %2 = felt.mul %0, %1 : !felt.type, !felt.type
      %3 = struct.readf %arg0[@"$temp"] : <@MulReg<[]>>, !struct.type<@NondetReg<[]>>
      function.call @NondetReg::@constrain(%3, %2) : (!struct.type<@NondetReg<[]>>, !felt.type) -> ()
      function.return
    }
  }
  struct.def @CheckBounds<[@COLORS, @PEGS]> {
    struct.field @"$super" : !array.type<@PEGS x !struct.type<@block$_1<[]>>>
    struct.field @"$temp_4" : !array.type<@PEGS x !struct.type<@block$_1<[]>>> {column}
    struct.field @"$temp_3" : !array.type<@PEGS x !struct.type<@Component<[]>>>
    struct.field @"$temp_2" : !array.type<@PEGS x !struct.type<@Assert<[]>>>
    struct.field @check : !array.type<@PEGS x !struct.type<@Reg<[]>>> {column}
    struct.field @"$temp_1" : !array.type<@PEGS,#map x !struct.type<@MulReg<[]>>>
    struct.field @"$temp_0" : !array.type<@PEGS x !struct.type<@NondetReg<[]>>> {column}
    struct.field @"$temp" : !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>> {column}
    struct.field @"$array_0" : !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>> {column}
    struct.field @"$array" : !array.type<@PEGS x !struct.type<@block$_1<[]>>>
    function.def @compute(%arg0: !struct.type<@Pegs<[@PEGS]>>) -> !struct.type<@CheckBounds<[@COLORS, @PEGS]>> attributes {function.allow_witness} {
      %0 = string.new "Not a valid color"
      %felt_const_1 = felt.const 1
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %self = struct.new : !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
      %1 = poly.read_const @COLORS : !felt.type
      %2 = struct.readf %arg0[@"$super"] : <@Pegs<[@PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
      %array = array.new  : <@PEGS x !struct.type<@block$_1<[]>>>
      %3 = array.len %2, %c0 : <@PEGS x !struct.type<@Reg<[]>>>
      scf.for %arg1 = %c0 to %3 step %c1 {
        %5 = array.read %2[%arg1] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %6 = poly.read_const @COLORS : index
        %array_0 = array.new{()[%6]} : <#map x !felt.type>
        %7 = poly.read_const @COLORS : index
        scf.for %arg2 = %c0 to %7 step %c1 {
          %42 = cast.tofelt %arg2 : index
          array.write %array_0[%arg2] = %42 : <#map x !felt.type>, !felt.type
        }
        %8 = poly.read_const @COLORS : index
        %array_1 = array.new{()[%8]} : <#map x !struct.type<@NondetReg<[]>>>
        %9 = array.len %array_0, %c0 : <#map x !felt.type>
        scf.for %arg2 = %c0 to %9 step %c1 {
          %42 = array.read %array_0[%arg2] : <#map x !felt.type>, !felt.type
          %43 = struct.readf %5[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
          %44 = struct.readf %43[@"$super"] : <@NondetReg<[]>>, !felt.type
          %45 = felt.sub %42, %44 : !felt.type, !felt.type
          %46 = function.call @NondetReg::@compute(%45) : (!felt.type) -> !struct.type<@NondetReg<[]>>
          %47 = struct.readf %self[@"$temp"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
          array.write %47[%arg1, %arg2] = %46 : <@PEGS,#map x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
          struct.writef %self[@"$temp"] = %47 : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
          %48 = struct.readf %self[@"$temp"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
          %49 = array.read %48[%arg1, %arg2] : <@PEGS,#map x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
          array.write %array_1[%arg2] = %49 : <#map x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
        } {original_op = "map"}
        %10 = struct.readf %self[@"$array_0"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
        array.insert %10[%arg1] = %array_1 : <@PEGS,#map x !struct.type<@NondetReg<[]>>>, <#map x !struct.type<@NondetReg<[]>>>
        struct.writef %self[@"$array_0"] = %10 : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
        %11 = struct.readf %self[@"$array_0"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
        %12 = array.extract %11[%arg1] : <@PEGS,#map x !struct.type<@NondetReg<[]>>>
        %13 = function.call @NondetReg::@compute(%felt_const_1) : (!felt.type) -> !struct.type<@NondetReg<[]>>
        %14 = struct.readf %self[@"$temp_0"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@NondetReg<[]>>>
        array.write %14[%arg1] = %13 : <@PEGS x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
        struct.writef %self[@"$temp_0"] = %14 : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@NondetReg<[]>>>
        %15 = struct.readf %self[@"$temp_0"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@NondetReg<[]>>>
        %16 = array.read %15[%arg1] : <@PEGS x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
        %17 = array.len %12, %c0 : <#map x !struct.type<@NondetReg<[]>>>
        %18 = scf.for %arg2 = %c0 to %17 step %c1 iter_args(%arg3 = %16) -> (!struct.type<@NondetReg<[]>>) {
          %42 = array.read %12[%arg2] : <#map x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
          %43 = function.call @MulReg::@compute(%arg3, %42) : (!struct.type<@NondetReg<[]>>, !struct.type<@NondetReg<[]>>) -> !struct.type<@MulReg<[]>>
          %44 = struct.readf %self[@"$temp_1"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@MulReg<[]>>>
          array.write %44[%arg1, %arg2] = %43 : <@PEGS,#map x !struct.type<@MulReg<[]>>>, !struct.type<@MulReg<[]>>
          struct.writef %self[@"$temp_1"] = %44 : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@MulReg<[]>>>
          %45 = struct.readf %self[@"$temp_1"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@MulReg<[]>>>
          %46 = array.read %45[%arg1, %arg2] : <@PEGS,#map x !struct.type<@MulReg<[]>>>, !struct.type<@MulReg<[]>>
          %47 = struct.readf %46[@"$super"] : <@MulReg<[]>>, !struct.type<@NondetReg<[]>>
          scf.yield %47 : !struct.type<@NondetReg<[]>>
        } {original_op = "reduce"}
        %19 = struct.readf %18[@"$super"] : <@NondetReg<[]>>, !felt.type
        %20 = function.call @Reg::@compute(%19) : (!felt.type) -> !struct.type<@Reg<[]>>
        %21 = struct.readf %self[@check] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
        array.write %21[%arg1] = %20 : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        struct.writef %self[@check] = %21 : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
        %22 = struct.readf %self[@check] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
        %23 = array.read %22[%arg1] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %24 = struct.readf %23[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %25 = struct.readf %24[@"$super"] : <@NondetReg<[]>>, !felt.type
        %26 = struct.readf %23[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %27 = struct.readf %26[@"$super"] : <@NondetReg<[]>>, !felt.type
        %28 = function.call @Assert::@compute(%27, %0) : (!felt.type, !string.type) -> !struct.type<@Assert<[]>>
        %29 = struct.readf %self[@"$temp_2"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Assert<[]>>>
        array.write %29[%arg1] = %28 : <@PEGS x !struct.type<@Assert<[]>>>, !struct.type<@Assert<[]>>
        struct.writef %self[@"$temp_2"] = %29 : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Assert<[]>>>
        %30 = struct.readf %self[@"$temp_2"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Assert<[]>>>
        %31 = array.read %30[%arg1] : <@PEGS x !struct.type<@Assert<[]>>>, !struct.type<@Assert<[]>>
        %32 = function.call @Component::@compute() : () -> !struct.type<@Component<[]>>
        %33 = struct.readf %self[@"$temp_3"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Component<[]>>>
        array.write %33[%arg1] = %32 : <@PEGS x !struct.type<@Component<[]>>>, !struct.type<@Component<[]>>
        struct.writef %self[@"$temp_3"] = %33 : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Component<[]>>>
        %34 = struct.readf %self[@"$temp_3"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Component<[]>>>
        %35 = array.read %34[%arg1] : <@PEGS x !struct.type<@Component<[]>>>, !struct.type<@Component<[]>>
        %36 = struct.readf %self[@check] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
        %37 = array.read %36[%arg1] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %38 = function.call @block$_1::@compute(%35, %37) : (!struct.type<@Component<[]>>, !struct.type<@Reg<[]>>) -> !struct.type<@block$_1<[]>>
        %39 = struct.readf %self[@"$temp_4"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@block$_1<[]>>>
        array.write %39[%arg1] = %38 : <@PEGS x !struct.type<@block$_1<[]>>>, !struct.type<@block$_1<[]>>
        struct.writef %self[@"$temp_4"] = %39 : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@block$_1<[]>>>
        %40 = struct.readf %self[@"$temp_4"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@block$_1<[]>>>
        %41 = array.read %40[%arg1] : <@PEGS x !struct.type<@block$_1<[]>>>, !struct.type<@block$_1<[]>>
        array.write %array[%arg1] = %41 : <@PEGS x !struct.type<@block$_1<[]>>>, !struct.type<@block$_1<[]>>
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@block$_1<[]>>>
      %4 = struct.readf %self[@"$array"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@block$_1<[]>>>
      struct.writef %self[@"$super"] = %4 : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@block$_1<[]>>>
      function.return %self : !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
    }
    function.def @constrain(%arg0: !struct.type<@CheckBounds<[@COLORS, @PEGS]>>, %arg1: !struct.type<@Pegs<[@PEGS]>>) attributes {function.allow_constraint} {
      %0 = string.new "Not a valid color"
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %1 = poly.read_const @COLORS : !felt.type
      %2 = struct.readf %arg1[@"$super"] : <@Pegs<[@PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
      %array = array.new  : <@PEGS x !struct.type<@block$_1<[]>>>
      %3 = array.len %2, %c0 : <@PEGS x !struct.type<@Reg<[]>>>
      scf.for %arg2 = %c0 to %3 step %c1 {
        %5 = array.read %2[%arg2] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %6 = poly.read_const @COLORS : index
        %array_0 = array.new{()[%6]} : <#map x !felt.type>
        %7 = poly.read_const @COLORS : index
        scf.for %arg3 = %c0 to %7 step %c1 {
          %37 = cast.tofelt %arg3 : index
          array.write %array_0[%arg3] = %37 : <#map x !felt.type>, !felt.type
        }
        %8 = poly.read_const @COLORS : index
        %array_1 = array.new{()[%8]} : <#map x !struct.type<@NondetReg<[]>>>
        %9 = array.len %array_0, %c0 : <#map x !felt.type>
        scf.for %arg3 = %c0 to %9 step %c1 {
          %37 = array.read %array_0[%arg3] : <#map x !felt.type>, !felt.type
          %38 = struct.readf %5[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
          %39 = struct.readf %38[@"$super"] : <@NondetReg<[]>>, !felt.type
          %40 = felt.sub %37, %39 : !felt.type, !felt.type
          %41 = struct.readf %arg0[@"$temp"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
          %42 = struct.readf %arg0[@"$temp"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
          %43 = array.read %42[%arg2, %arg3] : <@PEGS,#map x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
          function.call @NondetReg::@constrain(%43, %40) : (!struct.type<@NondetReg<[]>>, !felt.type) -> ()
          array.write %array_1[%arg3] = %43 : <#map x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
        } {original_op = "map"}
        %10 = struct.readf %arg0[@"$array_0"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
        %11 = struct.readf %arg0[@"$array_0"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@NondetReg<[]>>>
        %12 = array.extract %11[%arg2] : <@PEGS,#map x !struct.type<@NondetReg<[]>>>
        %13 = struct.readf %arg0[@"$temp_0"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@NondetReg<[]>>>
        %14 = struct.readf %arg0[@"$temp_0"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@NondetReg<[]>>>
        %15 = array.read %14[%arg2] : <@PEGS x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
        function.call @NondetReg::@constrain(%15, %felt_const_1) : (!struct.type<@NondetReg<[]>>, !felt.type) -> ()
        %16 = array.len %12, %c0 : <#map x !struct.type<@NondetReg<[]>>>
        %17 = scf.for %arg3 = %c0 to %16 step %c1 iter_args(%arg4 = %15) -> (!struct.type<@NondetReg<[]>>) {
          %37 = array.read %12[%arg3] : <#map x !struct.type<@NondetReg<[]>>>, !struct.type<@NondetReg<[]>>
          %38 = struct.readf %arg0[@"$temp_1"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@MulReg<[]>>>
          %39 = struct.readf %arg0[@"$temp_1"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS,#map x !struct.type<@MulReg<[]>>>
          %40 = array.read %39[%arg2, %arg3] : <@PEGS,#map x !struct.type<@MulReg<[]>>>, !struct.type<@MulReg<[]>>
          function.call @MulReg::@constrain(%40, %arg4, %37) : (!struct.type<@MulReg<[]>>, !struct.type<@NondetReg<[]>>, !struct.type<@NondetReg<[]>>) -> ()
          %41 = struct.readf %40[@"$super"] : <@MulReg<[]>>, !struct.type<@NondetReg<[]>>
          scf.yield %41 : !struct.type<@NondetReg<[]>>
        } {original_op = "reduce"}
        %18 = struct.readf %17[@"$super"] : <@NondetReg<[]>>, !felt.type
        %19 = struct.readf %arg0[@check] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
        %20 = struct.readf %arg0[@check] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
        %21 = array.read %20[%arg2] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        function.call @Reg::@constrain(%21, %18) : (!struct.type<@Reg<[]>>, !felt.type) -> ()
        %22 = struct.readf %21[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %23 = struct.readf %22[@"$super"] : <@NondetReg<[]>>, !felt.type
        constrain.eq %23, %felt_const_0 : !felt.type, !felt.type
        %24 = struct.readf %21[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %25 = struct.readf %24[@"$super"] : <@NondetReg<[]>>, !felt.type
        %26 = struct.readf %arg0[@"$temp_2"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Assert<[]>>>
        %27 = struct.readf %arg0[@"$temp_2"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Assert<[]>>>
        %28 = array.read %27[%arg2] : <@PEGS x !struct.type<@Assert<[]>>>, !struct.type<@Assert<[]>>
        function.call @Assert::@constrain(%28, %25, %0) : (!struct.type<@Assert<[]>>, !felt.type, !string.type) -> ()
        %29 = struct.readf %arg0[@"$temp_3"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Component<[]>>>
        %30 = struct.readf %arg0[@"$temp_3"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Component<[]>>>
        %31 = array.read %30[%arg2] : <@PEGS x !struct.type<@Component<[]>>>, !struct.type<@Component<[]>>
        function.call @Component::@constrain(%31) : (!struct.type<@Component<[]>>) -> ()
        %32 = struct.readf %arg0[@check] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
        %33 = array.read %32[%arg2] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %34 = struct.readf %arg0[@"$temp_4"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@block$_1<[]>>>
        %35 = struct.readf %arg0[@"$temp_4"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@block$_1<[]>>>
        %36 = array.read %35[%arg2] : <@PEGS x !struct.type<@block$_1<[]>>>, !struct.type<@block$_1<[]>>
        function.call @block$_1::@constrain(%36, %31, %33) : (!struct.type<@block$_1<[]>>, !struct.type<@Component<[]>>, !struct.type<@Reg<[]>>) -> ()
        array.write %array[%arg2] = %36 : <@PEGS x !struct.type<@block$_1<[]>>>, !struct.type<@block$_1<[]>>
      } {original_op = "map"}
      %4 = struct.readf %arg0[@"$array"] : <@CheckBounds<[@COLORS, @PEGS]>>, !array.type<@PEGS x !struct.type<@block$_1<[]>>>
      function.return
    }
  }
  struct.def @CodeHash<[]> {
    struct.field @"$super" : !array.type<24 x !felt.type>
    function.def @compute(%arg0: !array.type<24 x !felt.type>) -> !struct.type<@CodeHash<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@CodeHash<[]>>
      struct.writef %self[@"$super"] = %arg0 : <@CodeHash<[]>>, !array.type<24 x !felt.type>
      function.return %self : !struct.type<@CodeHash<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@CodeHash<[]>>, %arg1: !array.type<24 x !felt.type>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @GenerateCodeHash<[@N]> {
    struct.field @"$super" : !struct.type<@CodeHash<[]>>
    struct.field @"$temp_1" : !struct.type<@CodeHash<[]>>
    struct.field @"$temp_0" : !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
    struct.field @stage2 : !struct.type<@DoIntRounds<[]>>
    struct.field @"$temp" : !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
    struct.field @stage0 : !struct.type<@MultiplyByMExt<[]>>
    struct.field @in : !array.type<24 x !felt.type>
    function.def @compute(%arg0: !struct.type<@Nonce<[]>>, %arg1: !struct.type<@Pegs<[@N]>>) -> !struct.type<@GenerateCodeHash<[@N]>> attributes {function.allow_witness} {
      %c4 = arith.constant 4 : index
      %felt_const_0 = felt.const 0
      %felt_const_24 = felt.const 24
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0_0 = felt.const 0
      %self = struct.new : !struct.type<@GenerateCodeHash<[@N]>>
      %0 = poly.read_const @N : !felt.type
      %array = array.new %felt_const_0_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_1 = array.new  : <24 x !felt.type>
      scf.for %arg2 = %c0 to %c24 step %c1 {
        %13 = array.read %array[%arg2] : <24 x !felt.type>, !felt.type
        %14 = bool.cmp eq(%13, %felt_const_0_0)
        %15 = cast.tofelt %14 : i1
        %16 = bool.cmp le(%felt_const_1, %13)
        %17 = bool.cmp lt(%13, %0)
        %18 = cast.tofelt %16 : i1
        %19 = cast.tofelt %17 : i1
        %20 = felt.mul %18, %19 : !felt.type, !felt.type
        %21 = bool.cmp le(%0, %13)
        %22 = bool.cmp lt(%13, %felt_const_24)
        %23 = cast.tofelt %21 : i1
        %24 = cast.tofelt %22 : i1
        %25 = felt.mul %23, %24 : !felt.type, !felt.type
        %array_4 = array.new %15, %20, %25 : <3 x !felt.type>
        %26 = cast.toindex %felt_const_0_0
        %27 = array.read %array_4[%26] : <3 x !felt.type>, !felt.type
        %28 = bool.cmp ne(%27, %felt_const_0)
        %29 = cast.toindex %felt_const_1
        %30 = array.read %array_4[%29] : <3 x !felt.type>, !felt.type
        %31 = bool.cmp ne(%30, %felt_const_0)
        %32 = cast.toindex %felt_const_2
        %33 = array.read %array_4[%32] : <3 x !felt.type>, !felt.type
        %34 = bool.cmp ne(%33, %felt_const_0)
        %35 = scf.if %28 -> (!felt.type) {
          %36 = struct.readf %arg0[@"$super"] : <@Nonce<[]>>, !struct.type<@Reg<[]>>
          %37 = struct.readf %36[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
          %38 = struct.readf %37[@"$super"] : <@NondetReg<[]>>, !felt.type
          scf.yield %38 : !felt.type
        } else {
          %36 = scf.if %31 -> (!felt.type) {
            %37 = felt.sub %13, %felt_const_1 : !felt.type, !felt.type
            %38 = struct.readf %arg1[@"$super"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
            %39 = cast.toindex %37
            %40 = array.read %38[%39] : <@N x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
            %41 = struct.readf %40[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
            %42 = struct.readf %41[@"$super"] : <@NondetReg<[]>>, !felt.type
            scf.yield %42 : !felt.type
          } else {
            bool.assert %34, ""
            scf.yield %felt_const_0_0 : !felt.type
          }
          scf.yield %36 : !felt.type
        }
        array.write %array_1[%arg2] = %35 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      struct.writef %self[@in] = %array_1 : <@GenerateCodeHash<[@N]>>, !array.type<24 x !felt.type>
      %1 = struct.readf %self[@in] : <@GenerateCodeHash<[@N]>>, !array.type<24 x !felt.type>
      %2 = function.call @MultiplyByMExt::@compute(%1) : (!array.type<24 x !felt.type>) -> !struct.type<@MultiplyByMExt<[]>>
      struct.writef %self[@stage0] = %2 : <@GenerateCodeHash<[@N]>>, !struct.type<@MultiplyByMExt<[]>>
      %3 = struct.readf %self[@stage0] : <@GenerateCodeHash<[@N]>>, !struct.type<@MultiplyByMExt<[]>>
      %array_2 = array.new %felt_const_0_0, %felt_const_1, %felt_const_2, %felt_const_3 : <4 x !felt.type>
      %4 = scf.for %arg2 = %c0 to %c4 step %c1 iter_args(%arg3 = %3) -> (!struct.type<@MultiplyByMExt<[]>>) {
        %13 = array.read %array_2[%arg2] : <4 x !felt.type>, !felt.type
        %14 = struct.readf %arg3[@"$super"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
        %array_4 = array.new  : <24 x !felt.type>
        %15 = array.len %14, %c0 : <24 x !struct.type<@block$<[]>>>
        scf.for %arg4 = %c0 to %c1 step %15 {
          %22 = array.read %14[%arg4] : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
          %23 = struct.readf %22[@"$super"] : <@block$<[]>>, !felt.type
          array.write %array_4[%arg4] = %23 : <24 x !felt.type>, !felt.type
        }
        %16 = function.call @DoExtRoundByIdx::@compute(%array_4, %13) : (!array.type<24 x !felt.type>, !felt.type) -> !struct.type<@DoExtRoundByIdx<[]>>
        %17 = struct.readf %self[@"$temp"] : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        array.write %17[%arg2] = %16 : <4 x !struct.type<@DoExtRoundByIdx<[]>>>, !struct.type<@DoExtRoundByIdx<[]>>
        struct.writef %self[@"$temp"] = %17 : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        %18 = struct.readf %self[@"$temp"] : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        %19 = array.read %18[%arg2] : <4 x !struct.type<@DoExtRoundByIdx<[]>>>, !struct.type<@DoExtRoundByIdx<[]>>
        %20 = struct.readf %19[@"$super"] : <@DoExtRoundByIdx<[]>>, !struct.type<@DoExtRound<[]>>
        %21 = struct.readf %20[@"$super"] : <@DoExtRound<[]>>, !struct.type<@MultiplyByMExt<[]>>
        scf.yield %21 : !struct.type<@MultiplyByMExt<[]>>
      } {original_op = "reduce"}
      %5 = struct.readf %4[@"$super"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
      %array_3 = array.new  : <24 x !felt.type>
      %6 = array.len %5, %c0 : <24 x !struct.type<@block$<[]>>>
      scf.for %arg2 = %c0 to %c1 step %6 {
        %13 = array.read %5[%arg2] : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
        %14 = struct.readf %13[@"$super"] : <@block$<[]>>, !felt.type
        array.write %array_3[%arg2] = %14 : <24 x !felt.type>, !felt.type
      }
      %7 = function.call @DoIntRounds::@compute(%array_3) : (!array.type<24 x !felt.type>) -> !struct.type<@DoIntRounds<[]>>
      struct.writef %self[@stage2] = %7 : <@GenerateCodeHash<[@N]>>, !struct.type<@DoIntRounds<[]>>
      %8 = struct.readf %self[@stage2] : <@GenerateCodeHash<[@N]>>, !struct.type<@DoIntRounds<[]>>
      %9 = struct.readf %8[@"$super"] : <@DoIntRounds<[]>>, !array.type<24 x !felt.type>
      %10 = scf.for %arg2 = %c0 to %c4 step %c1 iter_args(%arg3 = %9) -> (!array.type<24 x !felt.type>) {
        %13 = array.read %array_2[%arg2] : <4 x !felt.type>, !felt.type
        %14 = function.call @DoExtRoundByIdx::@compute(%arg3, %13) : (!array.type<24 x !felt.type>, !felt.type) -> !struct.type<@DoExtRoundByIdx<[]>>
        %15 = struct.readf %self[@"$temp_0"] : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        array.write %15[%arg2] = %14 : <4 x !struct.type<@DoExtRoundByIdx<[]>>>, !struct.type<@DoExtRoundByIdx<[]>>
        struct.writef %self[@"$temp_0"] = %15 : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        %16 = struct.readf %self[@"$temp_0"] : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        %17 = array.read %16[%arg2] : <4 x !struct.type<@DoExtRoundByIdx<[]>>>, !struct.type<@DoExtRoundByIdx<[]>>
        %18 = struct.readf %17[@"$super"] : <@DoExtRoundByIdx<[]>>, !struct.type<@DoExtRound<[]>>
        %19 = struct.readf %18[@"$super"] : <@DoExtRound<[]>>, !struct.type<@MultiplyByMExt<[]>>
        %20 = struct.readf %19[@"$super"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
        %array_4 = array.new  : <24 x !felt.type>
        %21 = array.len %20, %c0 : <24 x !struct.type<@block$<[]>>>
        scf.for %arg4 = %c0 to %c1 step %21 {
          %22 = array.read %20[%arg4] : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
          %23 = struct.readf %22[@"$super"] : <@block$<[]>>, !felt.type
          array.write %array_4[%arg4] = %23 : <24 x !felt.type>, !felt.type
        }
        scf.yield %array_4 : !array.type<24 x !felt.type>
      } {original_op = "reduce"}
      %11 = function.call @CodeHash::@compute(%10) : (!array.type<24 x !felt.type>) -> !struct.type<@CodeHash<[]>>
      struct.writef %self[@"$temp_1"] = %11 : <@GenerateCodeHash<[@N]>>, !struct.type<@CodeHash<[]>>
      %12 = struct.readf %self[@"$temp_1"] : <@GenerateCodeHash<[@N]>>, !struct.type<@CodeHash<[]>>
      struct.writef %self[@"$super"] = %12 : <@GenerateCodeHash<[@N]>>, !struct.type<@CodeHash<[]>>
      function.return %self : !struct.type<@GenerateCodeHash<[@N]>>
    }
    function.def @constrain(%arg0: !struct.type<@GenerateCodeHash<[@N]>>, %arg1: !struct.type<@Nonce<[]>>, %arg2: !struct.type<@Pegs<[@N]>>) attributes {function.allow_constraint} {
      %c4 = arith.constant 4 : index
      %felt_const_0 = felt.const 0
      %felt_const_24 = felt.const 24
      %c24 = arith.constant 24 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %felt_const_23 = felt.const 23
      %felt_const_22 = felt.const 22
      %felt_const_21 = felt.const 21
      %felt_const_20 = felt.const 20
      %felt_const_19 = felt.const 19
      %felt_const_18 = felt.const 18
      %felt_const_17 = felt.const 17
      %felt_const_16 = felt.const 16
      %felt_const_15 = felt.const 15
      %felt_const_14 = felt.const 14
      %felt_const_13 = felt.const 13
      %felt_const_12 = felt.const 12
      %felt_const_11 = felt.const 11
      %felt_const_10 = felt.const 10
      %felt_const_9 = felt.const 9
      %felt_const_8 = felt.const 8
      %felt_const_7 = felt.const 7
      %felt_const_6 = felt.const 6
      %felt_const_5 = felt.const 5
      %felt_const_4 = felt.const 4
      %felt_const_3 = felt.const 3
      %felt_const_2 = felt.const 2
      %felt_const_1 = felt.const 1
      %felt_const_0_0 = felt.const 0
      %0 = poly.read_const @N : !felt.type
      %array = array.new %felt_const_0_0, %felt_const_1, %felt_const_2, %felt_const_3, %felt_const_4, %felt_const_5, %felt_const_6, %felt_const_7, %felt_const_8, %felt_const_9, %felt_const_10, %felt_const_11, %felt_const_12, %felt_const_13, %felt_const_14, %felt_const_15, %felt_const_16, %felt_const_17, %felt_const_18, %felt_const_19, %felt_const_20, %felt_const_21, %felt_const_22, %felt_const_23 : <24 x !felt.type>
      %array_1 = array.new  : <24 x !felt.type>
      scf.for %arg3 = %c0 to %c24 step %c1 {
        %10 = array.read %array[%arg3] : <24 x !felt.type>, !felt.type
        %11 = bool.cmp eq(%10, %felt_const_0_0)
        %12 = cast.tofelt %11 : i1
        %13 = bool.cmp le(%felt_const_1, %10)
        %14 = bool.cmp lt(%10, %0)
        %15 = cast.tofelt %13 : i1
        %16 = cast.tofelt %14 : i1
        %17 = felt.mul %15, %16 : !felt.type, !felt.type
        %18 = bool.cmp le(%0, %10)
        %19 = bool.cmp lt(%10, %felt_const_24)
        %20 = cast.tofelt %18 : i1
        %21 = cast.tofelt %19 : i1
        %22 = felt.mul %20, %21 : !felt.type, !felt.type
        %array_4 = array.new %12, %17, %22 : <3 x !felt.type>
        %23 = cast.toindex %felt_const_0_0
        %24 = array.read %array_4[%23] : <3 x !felt.type>, !felt.type
        %25 = bool.cmp ne(%24, %felt_const_0)
        %26 = cast.toindex %felt_const_1
        %27 = array.read %array_4[%26] : <3 x !felt.type>, !felt.type
        %28 = bool.cmp ne(%27, %felt_const_0)
        %29 = cast.toindex %felt_const_2
        %30 = array.read %array_4[%29] : <3 x !felt.type>, !felt.type
        %31 = bool.cmp ne(%30, %felt_const_0)
        %32 = scf.if %25 -> (!felt.type) {
          %33 = struct.readf %arg1[@"$super"] : <@Nonce<[]>>, !struct.type<@Reg<[]>>
          %34 = struct.readf %33[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
          %35 = struct.readf %34[@"$super"] : <@NondetReg<[]>>, !felt.type
          scf.yield %35 : !felt.type
        } else {
          %33 = scf.if %28 -> (!felt.type) {
            %34 = felt.sub %10, %felt_const_1 : !felt.type, !felt.type
            %35 = struct.readf %arg2[@"$super"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
            %36 = cast.toindex %34
            %37 = array.read %35[%36] : <@N x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
            %38 = struct.readf %37[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
            %39 = struct.readf %38[@"$super"] : <@NondetReg<[]>>, !felt.type
            scf.yield %39 : !felt.type
          } else {
            bool.assert %31, ""
            scf.yield %felt_const_0_0 : !felt.type
          }
          scf.yield %33 : !felt.type
        }
        array.write %array_1[%arg3] = %32 : <24 x !felt.type>, !felt.type
      } {original_op = "map"}
      %1 = struct.readf %arg0[@in] : <@GenerateCodeHash<[@N]>>, !array.type<24 x !felt.type>
      %2 = struct.readf %arg0[@stage0] : <@GenerateCodeHash<[@N]>>, !struct.type<@MultiplyByMExt<[]>>
      function.call @MultiplyByMExt::@constrain(%2, %1) : (!struct.type<@MultiplyByMExt<[]>>, !array.type<24 x !felt.type>) -> ()
      %array_2 = array.new %felt_const_0_0, %felt_const_1, %felt_const_2, %felt_const_3 : <4 x !felt.type>
      %3 = scf.for %arg3 = %c0 to %c4 step %c1 iter_args(%arg4 = %2) -> (!struct.type<@MultiplyByMExt<[]>>) {
        %10 = array.read %array_2[%arg3] : <4 x !felt.type>, !felt.type
        %11 = struct.readf %arg4[@"$super"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
        %array_4 = array.new  : <24 x !felt.type>
        %12 = array.len %11, %c0 : <24 x !struct.type<@block$<[]>>>
        scf.for %arg5 = %c0 to %c1 step %12 {
          %18 = array.read %11[%arg5] : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
          %19 = struct.readf %18[@"$super"] : <@block$<[]>>, !felt.type
          array.write %array_4[%arg5] = %19 : <24 x !felt.type>, !felt.type
        }
        %13 = struct.readf %arg0[@"$temp"] : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        %14 = struct.readf %arg0[@"$temp"] : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        %15 = array.read %14[%arg3] : <4 x !struct.type<@DoExtRoundByIdx<[]>>>, !struct.type<@DoExtRoundByIdx<[]>>
        function.call @DoExtRoundByIdx::@constrain(%15, %array_4, %10) : (!struct.type<@DoExtRoundByIdx<[]>>, !array.type<24 x !felt.type>, !felt.type) -> ()
        %16 = struct.readf %15[@"$super"] : <@DoExtRoundByIdx<[]>>, !struct.type<@DoExtRound<[]>>
        %17 = struct.readf %16[@"$super"] : <@DoExtRound<[]>>, !struct.type<@MultiplyByMExt<[]>>
        scf.yield %17 : !struct.type<@MultiplyByMExt<[]>>
      } {original_op = "reduce"}
      %4 = struct.readf %3[@"$super"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
      %array_3 = array.new  : <24 x !felt.type>
      %5 = array.len %4, %c0 : <24 x !struct.type<@block$<[]>>>
      scf.for %arg3 = %c0 to %c1 step %5 {
        %10 = array.read %4[%arg3] : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
        %11 = struct.readf %10[@"$super"] : <@block$<[]>>, !felt.type
        array.write %array_3[%arg3] = %11 : <24 x !felt.type>, !felt.type
      }
      %6 = struct.readf %arg0[@stage2] : <@GenerateCodeHash<[@N]>>, !struct.type<@DoIntRounds<[]>>
      function.call @DoIntRounds::@constrain(%6, %array_3) : (!struct.type<@DoIntRounds<[]>>, !array.type<24 x !felt.type>) -> ()
      %7 = struct.readf %6[@"$super"] : <@DoIntRounds<[]>>, !array.type<24 x !felt.type>
      %8 = scf.for %arg3 = %c0 to %c4 step %c1 iter_args(%arg4 = %7) -> (!array.type<24 x !felt.type>) {
        %10 = array.read %array_2[%arg3] : <4 x !felt.type>, !felt.type
        %11 = struct.readf %arg0[@"$temp_0"] : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        %12 = struct.readf %arg0[@"$temp_0"] : <@GenerateCodeHash<[@N]>>, !array.type<4 x !struct.type<@DoExtRoundByIdx<[]>>>
        %13 = array.read %12[%arg3] : <4 x !struct.type<@DoExtRoundByIdx<[]>>>, !struct.type<@DoExtRoundByIdx<[]>>
        function.call @DoExtRoundByIdx::@constrain(%13, %arg4, %10) : (!struct.type<@DoExtRoundByIdx<[]>>, !array.type<24 x !felt.type>, !felt.type) -> ()
        %14 = struct.readf %13[@"$super"] : <@DoExtRoundByIdx<[]>>, !struct.type<@DoExtRound<[]>>
        %15 = struct.readf %14[@"$super"] : <@DoExtRound<[]>>, !struct.type<@MultiplyByMExt<[]>>
        %16 = struct.readf %15[@"$super"] : <@MultiplyByMExt<[]>>, !array.type<24 x !struct.type<@block$<[]>>>
        %array_4 = array.new  : <24 x !felt.type>
        %17 = array.len %16, %c0 : <24 x !struct.type<@block$<[]>>>
        scf.for %arg5 = %c0 to %c1 step %17 {
          %18 = array.read %16[%arg5] : <24 x !struct.type<@block$<[]>>>, !struct.type<@block$<[]>>
          %19 = struct.readf %18[@"$super"] : <@block$<[]>>, !felt.type
          array.write %array_4[%arg5] = %19 : <24 x !felt.type>, !felt.type
        }
        scf.yield %array_4 : !array.type<24 x !felt.type>
      } {original_op = "reduce"}
      %9 = struct.readf %arg0[@"$temp_1"] : <@GenerateCodeHash<[@N]>>, !struct.type<@CodeHash<[]>>
      function.call @CodeHash::@constrain(%9, %8) : (!struct.type<@CodeHash<[]>>, !array.type<24 x !felt.type>) -> ()
      function.return
    }
  }
  struct.def @SetCode<[@COLORS, @PEGS]> {
    struct.field @"$super" : !struct.type<@GenerateCodeHash<[@PEGS]>>
    struct.field @"$temp_0" : !struct.type<@GenerateCodeHash<[@PEGS]>>
    struct.field @"$temp" : !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
    function.def @compute(%arg0: !struct.type<@Nonce<[]>>, %arg1: !struct.type<@Pegs<[@PEGS]>>) -> !struct.type<@SetCode<[@COLORS, @PEGS]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@SetCode<[@COLORS, @PEGS]>>
      %0 = function.call @CheckBounds::@compute(%arg1) : (!struct.type<@Pegs<[@PEGS]>>) -> !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
      struct.writef %self[@"$temp"] = %0 : <@SetCode<[@COLORS, @PEGS]>>, !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
      %1 = struct.readf %self[@"$temp"] : <@SetCode<[@COLORS, @PEGS]>>, !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
      %2 = function.call @GenerateCodeHash::@compute(%arg0, %arg1) : (!struct.type<@Nonce<[]>>, !struct.type<@Pegs<[@PEGS]>>) -> !struct.type<@GenerateCodeHash<[@PEGS]>>
      struct.writef %self[@"$temp_0"] = %2 : <@SetCode<[@COLORS, @PEGS]>>, !struct.type<@GenerateCodeHash<[@PEGS]>>
      %3 = struct.readf %self[@"$temp_0"] : <@SetCode<[@COLORS, @PEGS]>>, !struct.type<@GenerateCodeHash<[@PEGS]>>
      struct.writef %self[@"$super"] = %3 : <@SetCode<[@COLORS, @PEGS]>>, !struct.type<@GenerateCodeHash<[@PEGS]>>
      function.return %self : !struct.type<@SetCode<[@COLORS, @PEGS]>>
    }
    function.def @constrain(%arg0: !struct.type<@SetCode<[@COLORS, @PEGS]>>, %arg1: !struct.type<@Nonce<[]>>, %arg2: !struct.type<@Pegs<[@PEGS]>>) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@"$temp"] : <@SetCode<[@COLORS, @PEGS]>>, !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
      function.call @CheckBounds::@constrain(%0, %arg2) : (!struct.type<@CheckBounds<[@COLORS, @PEGS]>>, !struct.type<@Pegs<[@PEGS]>>) -> ()
      %1 = struct.readf %arg0[@"$temp_0"] : <@SetCode<[@COLORS, @PEGS]>>, !struct.type<@GenerateCodeHash<[@PEGS]>>
      function.call @GenerateCodeHash::@constrain(%1, %arg1, %arg2) : (!struct.type<@GenerateCodeHash<[@PEGS]>>, !struct.type<@Nonce<[]>>, !struct.type<@Pegs<[@PEGS]>>) -> ()
      function.return
    }
  }
  struct.def @Minimum<[]> {
    struct.field @"$super" : !felt.type
    struct.field @"$temp_0" : !struct.type<@NondetReg<[]>> {column}
    struct.field @"$temp" : !struct.type<@NondetReg<[]>> {column}
    function.def @compute(%arg0: !felt.type, %arg1: !felt.type) -> !struct.type<@Minimum<[]>> attributes {function.allow_witness} {
      %felt_const_0 = felt.const 0
      %felt_const_1 = felt.const 1
      %felt_const_0_0 = felt.const 0
      %self = struct.new : !struct.type<@Minimum<[]>>
      %0 = bool.cmp le(%felt_const_0_0, %arg0)
      %1 = bool.cmp lt(%arg0, %arg1)
      %2 = cast.tofelt %0 : i1
      %3 = cast.tofelt %1 : i1
      %4 = felt.mul %2, %3 : !felt.type, !felt.type
      %5 = function.call @NondetReg::@compute(%4) : (!felt.type) -> !struct.type<@NondetReg<[]>>
      struct.writef %self[@"$temp"] = %5 : <@Minimum<[]>>, !struct.type<@NondetReg<[]>>
      %6 = struct.readf %self[@"$temp"] : <@Minimum<[]>>, !struct.type<@NondetReg<[]>>
      %7 = function.call @NondetReg::@compute(%4) : (!felt.type) -> !struct.type<@NondetReg<[]>>
      struct.writef %self[@"$temp_0"] = %7 : <@Minimum<[]>>, !struct.type<@NondetReg<[]>>
      %8 = struct.readf %self[@"$temp_0"] : <@Minimum<[]>>, !struct.type<@NondetReg<[]>>
      %9 = struct.readf %8[@"$super"] : <@NondetReg<[]>>, !felt.type
      %10 = felt.sub %felt_const_1, %9 : !felt.type, !felt.type
      %11 = struct.readf %6[@"$super"] : <@NondetReg<[]>>, !felt.type
      %array = array.new %11, %10 : <2 x !felt.type>
      %12 = cast.toindex %felt_const_0_0
      %13 = array.read %array[%12] : <2 x !felt.type>, !felt.type
      %14 = bool.cmp ne(%13, %felt_const_0)
      %15 = cast.toindex %felt_const_1
      %16 = array.read %array[%15] : <2 x !felt.type>, !felt.type
      %17 = bool.cmp ne(%16, %felt_const_0)
      %18 = arith.select %14, %arg0, %arg1 : !felt.type
      scf.if %14 {
      } else {
        bool.assert %17, ""
      }
      struct.writef %self[@"$super"] = %18 : <@Minimum<[]>>, !felt.type
      function.return %self : !struct.type<@Minimum<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Minimum<[]>>, %arg1: !felt.type, %arg2: !felt.type) attributes {function.allow_constraint} {
      %felt_const_0 = felt.const 0
      %felt_const_1 = felt.const 1
      %felt_const_0_0 = felt.const 0
      %0 = bool.cmp le(%felt_const_0_0, %arg1)
      %1 = bool.cmp lt(%arg1, %arg2)
      %2 = cast.tofelt %0 : i1
      %3 = cast.tofelt %1 : i1
      %4 = felt.mul %2, %3 : !felt.type, !felt.type
      %5 = struct.readf %arg0[@"$temp"] : <@Minimum<[]>>, !struct.type<@NondetReg<[]>>
      function.call @NondetReg::@constrain(%5, %4) : (!struct.type<@NondetReg<[]>>, !felt.type) -> ()
      %6 = struct.readf %arg0[@"$temp_0"] : <@Minimum<[]>>, !struct.type<@NondetReg<[]>>
      function.call @NondetReg::@constrain(%6, %4) : (!struct.type<@NondetReg<[]>>, !felt.type) -> ()
      %7 = struct.readf %6[@"$super"] : <@NondetReg<[]>>, !felt.type
      %8 = felt.sub %felt_const_1, %7 : !felt.type, !felt.type
      %9 = struct.readf %5[@"$super"] : <@NondetReg<[]>>, !felt.type
      %array = array.new %9, %8 : <2 x !felt.type>
      %10 = cast.toindex %felt_const_0_0
      %11 = array.read %array[%10] : <2 x !felt.type>, !felt.type
      %12 = bool.cmp ne(%11, %felt_const_0)
      %13 = cast.toindex %felt_const_1
      %14 = array.read %array[%13] : <2 x !felt.type>, !felt.type
      %15 = bool.cmp ne(%14, %felt_const_0)
      scf.if %12 {
      } else {
        bool.assert %15, ""
      }
      function.return
    }
  }
  struct.def @CountColors<[@N]> {
    struct.field @"$super" : !felt.type
    struct.field @"$temp_0" : !array.type<@N x !felt.type>
    struct.field @"$temp" : !array.type<@N x !struct.type<@IsZero<[]>>> {column}
    struct.field @"$array" : !array.type<@N x !struct.type<@IsZero<[]>>> {column}
    function.def @compute(%arg0: !struct.type<@Pegs<[@N]>>, %arg1: !felt.type) -> !struct.type<@CountColors<[@N]>> attributes {function.allow_witness} {
      %felt_const_0 = felt.const 0
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %self = struct.new : !struct.type<@CountColors<[@N]>>
      %0 = struct.readf %arg0[@"$super"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
      %array = array.new  : <@N x !struct.type<@IsZero<[]>>>
      %1 = array.len %0, %c0 : <@N x !struct.type<@Reg<[]>>>
      scf.for %arg2 = %c0 to %1 step %c1 {
        %5 = array.read %0[%arg2] : <@N x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %6 = struct.readf %5[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %7 = struct.readf %6[@"$super"] : <@NondetReg<[]>>, !felt.type
        %8 = felt.sub %7, %arg1 : !felt.type, !felt.type
        %9 = function.call @IsZero::@compute(%8) : (!felt.type) -> !struct.type<@IsZero<[]>>
        %10 = struct.readf %self[@"$temp"] : <@CountColors<[@N]>>, !array.type<@N x !struct.type<@IsZero<[]>>>
        array.write %10[%arg2] = %9 : <@N x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        struct.writef %self[@"$temp"] = %10 : <@CountColors<[@N]>>, !array.type<@N x !struct.type<@IsZero<[]>>>
        %11 = struct.readf %self[@"$temp"] : <@CountColors<[@N]>>, !array.type<@N x !struct.type<@IsZero<[]>>>
        %12 = array.read %11[%arg2] : <@N x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        array.write %array[%arg2] = %12 : <@N x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array : <@CountColors<[@N]>>, !array.type<@N x !struct.type<@IsZero<[]>>>
      %2 = struct.readf %self[@"$array"] : <@CountColors<[@N]>>, !array.type<@N x !struct.type<@IsZero<[]>>>
      %3 = array.len %2, %c0 : <@N x !struct.type<@IsZero<[]>>>
      %4 = scf.for %arg2 = %c0 to %3 step %c1 iter_args(%arg3 = %felt_const_0) -> (!felt.type) {
        %5 = array.read %2[%arg2] : <@N x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        %6 = struct.readf %5[@"$super"] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
        %7 = struct.readf %6[@"$super"] : <@NondetReg<[]>>, !felt.type
        %8 = felt.add %arg3, %7 : !felt.type, !felt.type
        %9 = struct.readf %self[@"$temp_0"] : <@CountColors<[@N]>>, !array.type<@N x !felt.type>
        array.write %9[%arg2] = %8 : <@N x !felt.type>, !felt.type
        struct.writef %self[@"$temp_0"] = %9 : <@CountColors<[@N]>>, !array.type<@N x !felt.type>
        %10 = struct.readf %self[@"$temp_0"] : <@CountColors<[@N]>>, !array.type<@N x !felt.type>
        %11 = array.read %10[%arg2] : <@N x !felt.type>, !felt.type
        scf.yield %11 : !felt.type
      } {original_op = "reduce"}
      struct.writef %self[@"$super"] = %4 : <@CountColors<[@N]>>, !felt.type
      function.return %self : !struct.type<@CountColors<[@N]>>
    }
    function.def @constrain(%arg0: !struct.type<@CountColors<[@N]>>, %arg1: !struct.type<@Pegs<[@N]>>, %arg2: !felt.type) attributes {function.allow_constraint} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %0 = struct.readf %arg1[@"$super"] : <@Pegs<[@N]>>, !array.type<@N x !struct.type<@Reg<[]>>>
      %array = array.new  : <@N x !struct.type<@IsZero<[]>>>
      %1 = array.len %0, %c0 : <@N x !struct.type<@Reg<[]>>>
      scf.for %arg3 = %c0 to %1 step %c1 {
        %4 = array.read %0[%arg3] : <@N x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %5 = struct.readf %4[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %6 = struct.readf %5[@"$super"] : <@NondetReg<[]>>, !felt.type
        %7 = felt.sub %6, %arg2 : !felt.type, !felt.type
        %8 = struct.readf %arg0[@"$temp"] : <@CountColors<[@N]>>, !array.type<@N x !struct.type<@IsZero<[]>>>
        %9 = struct.readf %arg0[@"$temp"] : <@CountColors<[@N]>>, !array.type<@N x !struct.type<@IsZero<[]>>>
        %10 = array.read %9[%arg3] : <@N x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        function.call @IsZero::@constrain(%10, %7) : (!struct.type<@IsZero<[]>>, !felt.type) -> ()
        array.write %array[%arg3] = %10 : <@N x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
      } {original_op = "map"}
      %2 = struct.readf %arg0[@"$array"] : <@CountColors<[@N]>>, !array.type<@N x !struct.type<@IsZero<[]>>>
      %3 = array.len %2, %c0 : <@N x !struct.type<@IsZero<[]>>>
      scf.for %arg3 = %c0 to %3 step %c1 {
        %4 = array.read %2[%arg3] : <@N x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        %5 = struct.readf %4[@"$super"] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
        %6 = struct.readf %5[@"$super"] : <@NondetReg<[]>>, !felt.type
        %7 = struct.readf %arg0[@"$temp_0"] : <@CountColors<[@N]>>, !array.type<@N x !felt.type>
        %8 = struct.readf %arg0[@"$temp_0"] : <@CountColors<[@N]>>, !array.type<@N x !felt.type>
        %9 = array.read %8[%arg3] : <@N x !felt.type>, !felt.type
      } {original_op = "reduce"}
      function.return
    }
  }
  struct.def @Guess<[]> {
    struct.field @"$super" : !struct.type<@Component<[]>>
    struct.field @"$temp" : !struct.type<@Component<[]>>
    struct.field @partial : !struct.type<@Reg<[]>> {column}
    struct.field @correct : !struct.type<@Reg<[]>> {column}
    function.def @compute(%arg0: !felt.type, %arg1: !felt.type) -> !struct.type<@Guess<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Guess<[]>>
      %0 = function.call @Reg::@compute(%arg0) : (!felt.type) -> !struct.type<@Reg<[]>>
      struct.writef %self[@correct] = %0 : <@Guess<[]>>, !struct.type<@Reg<[]>>
      %1 = struct.readf %self[@correct] : <@Guess<[]>>, !struct.type<@Reg<[]>>
      %2 = function.call @Reg::@compute(%arg1) : (!felt.type) -> !struct.type<@Reg<[]>>
      struct.writef %self[@partial] = %2 : <@Guess<[]>>, !struct.type<@Reg<[]>>
      %3 = struct.readf %self[@partial] : <@Guess<[]>>, !struct.type<@Reg<[]>>
      %4 = function.call @Component::@compute() : () -> !struct.type<@Component<[]>>
      struct.writef %self[@"$temp"] = %4 : <@Guess<[]>>, !struct.type<@Component<[]>>
      %5 = struct.readf %self[@"$temp"] : <@Guess<[]>>, !struct.type<@Component<[]>>
      struct.writef %self[@"$super"] = %5 : <@Guess<[]>>, !struct.type<@Component<[]>>
      function.return %self : !struct.type<@Guess<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Guess<[]>>, %arg1: !felt.type, %arg2: !felt.type) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@correct] : <@Guess<[]>>, !struct.type<@Reg<[]>>
      function.call @Reg::@constrain(%0, %arg1) : (!struct.type<@Reg<[]>>, !felt.type) -> ()
      %1 = struct.readf %arg0[@partial] : <@Guess<[]>>, !struct.type<@Reg<[]>>
      function.call @Reg::@constrain(%1, %arg2) : (!struct.type<@Reg<[]>>, !felt.type) -> ()
      %2 = struct.readf %arg0[@"$temp"] : <@Guess<[]>>, !struct.type<@Component<[]>>
      function.call @Component::@constrain(%2) : (!struct.type<@Component<[]>>) -> ()
      function.return
    }
  }
  struct.def @Pair<[@Fst, @Snd]> {
    struct.field @"$super" : !struct.type<@Component<[]>>
    struct.field @"$temp" : !struct.type<@Component<[]>>
    struct.field @snd : !poly.tvar<@Snd>
    struct.field @fst : !poly.tvar<@Fst>
    function.def @compute(%arg0: !poly.tvar<@Fst>, %arg1: !poly.tvar<@Snd>) -> !struct.type<@Pair<[@Fst, @Snd]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@Pair<[@Fst, @Snd]>>
      struct.writef %self[@fst] = %arg0 : <@Pair<[@Fst, @Snd]>>, !poly.tvar<@Fst>
      struct.writef %self[@snd] = %arg1 : <@Pair<[@Fst, @Snd]>>, !poly.tvar<@Snd>
      %0 = function.call @Component::@compute() : () -> !struct.type<@Component<[]>>
      struct.writef %self[@"$temp"] = %0 : <@Pair<[@Fst, @Snd]>>, !struct.type<@Component<[]>>
      %1 = struct.readf %self[@"$temp"] : <@Pair<[@Fst, @Snd]>>, !struct.type<@Component<[]>>
      struct.writef %self[@"$super"] = %1 : <@Pair<[@Fst, @Snd]>>, !struct.type<@Component<[]>>
      function.return %self : !struct.type<@Pair<[@Fst, @Snd]>>
    }
    function.def @constrain(%arg0: !struct.type<@Pair<[@Fst, @Snd]>>, %arg1: !poly.tvar<@Fst>, %arg2: !poly.tvar<@Snd>) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@"$temp"] : <@Pair<[@Fst, @Snd]>>, !struct.type<@Component<[]>>
      function.call @Component::@constrain(%0) : (!struct.type<@Component<[]>>) -> ()
      function.return
    }
  }
  struct.def @Zip<[@Lhs, @Rhs, @N]> {
    struct.field @"$super" : !array.type<#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>
    struct.field @"$array" : !array.type<#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>
    function.def @compute(%arg0: !array.type<@N x !poly.tvar<@Lhs>>, %arg1: !array.type<@N x !poly.tvar<@Rhs>>) -> !struct.type<@Zip<[@Lhs, @Rhs, @N]>> attributes {function.allow_witness} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %self = struct.new : !struct.type<@Zip<[@Lhs, @Rhs, @N]>>
      %0 = poly.read_const @N : !felt.type
      %1 = poly.read_const @N : index
      %array = array.new{()[%1]} : <#map x !felt.type>
      %2 = poly.read_const @N : index
      scf.for %arg2 = %c0 to %2 step %c1 {
        %6 = cast.tofelt %arg2 : index
        array.write %array[%arg2] = %6 : <#map x !felt.type>, !felt.type
      }
      %3 = poly.read_const @N : index
      %array_0 = array.new{()[%3]} : <#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>
      %4 = array.len %array, %c0 : <#map x !felt.type>
      scf.for %arg2 = %c0 to %4 step %c1 {
        %6 = array.read %array[%arg2] : <#map x !felt.type>, !felt.type
        %7 = cast.toindex %6
        %8 = array.read %arg0[%7] : <@N x !poly.tvar<@Lhs>>, !poly.tvar<@Lhs>
        %9 = cast.toindex %6
        %10 = array.read %arg1[%9] : <@N x !poly.tvar<@Rhs>>, !poly.tvar<@Rhs>
        %11 = function.call @Pair::@compute(%8, %10) : (!poly.tvar<@Lhs>, !poly.tvar<@Rhs>) -> !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>
        array.write %array_0[%arg2] = %11 : <#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>, !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_0 : <@Zip<[@Lhs, @Rhs, @N]>>, !array.type<#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>
      %5 = struct.readf %self[@"$array"] : <@Zip<[@Lhs, @Rhs, @N]>>, !array.type<#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>
      struct.writef %self[@"$super"] = %5 : <@Zip<[@Lhs, @Rhs, @N]>>, !array.type<#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>
      function.return %self : !struct.type<@Zip<[@Lhs, @Rhs, @N]>>
    }
    function.def @constrain(%arg0: !struct.type<@Zip<[@Lhs, @Rhs, @N]>>, %arg1: !array.type<@N x !poly.tvar<@Lhs>>, %arg2: !array.type<@N x !poly.tvar<@Rhs>>) attributes {function.allow_constraint} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %0 = poly.read_const @N : !felt.type
      %1 = poly.read_const @N : index
      %array = array.new{()[%1]} : <#map x !felt.type>
      %2 = poly.read_const @N : index
      scf.for %arg3 = %c0 to %2 step %c1 {
        %6 = cast.tofelt %arg3 : index
        array.write %array[%arg3] = %6 : <#map x !felt.type>, !felt.type
      }
      %3 = poly.read_const @N : index
      %array_0 = array.new{()[%3]} : <#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>
      %4 = array.len %array, %c0 : <#map x !felt.type>
      scf.for %arg3 = %c0 to %4 step %c1 {
        %6 = array.read %array[%arg3] : <#map x !felt.type>, !felt.type
        %7 = cast.toindex %6
        %8 = array.read %arg1[%7] : <@N x !poly.tvar<@Lhs>>, !poly.tvar<@Lhs>
        %9 = cast.toindex %6
        %10 = array.read %arg2[%9] : <@N x !poly.tvar<@Rhs>>, !poly.tvar<@Rhs>
        %12 = struct.readf %arg0[@"$array"] : <@Zip<[@Lhs, @Rhs, @N]>>, !array.type<#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>
        %13 = array.read %12[%arg3] : <#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>, !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>
        function.call @Pair::@constrain(%13, %8, %10) : (!struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>, !poly.tvar<@Lhs>, !poly.tvar<@Rhs>) -> ()
        array.write %array_0[%arg3] = %13 : <#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>, !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>
      } {original_op = "map"}
      %5 = struct.readf %arg0[@"$array"] : <@Zip<[@Lhs, @Rhs, @N]>>, !array.type<#map x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>>
      function.return
    }
  }
  struct.def @AssertArrsEq<[@T, @N]> {
    struct.field @"$super" : !array.type<#map x !struct.type<@Component<[]>>>
    struct.field @"$temp_1" : !array.type<#map x !struct.type<@Component<[]>>>
    struct.field @"$temp_0" : !array.type<#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>> {column}
    struct.field @"$array" : !array.type<#map x !struct.type<@Component<[]>>>
    struct.field @"$temp" : !struct.type<@Zip<[!poly.tvar<@T>, !poly.tvar<@T>, @N]>>
    function.def @compute(%arg0: !array.type<@N x !poly.tvar<@T>>, %arg1: !array.type<@N x !poly.tvar<@T>>) -> !struct.type<@AssertArrsEq<[@T, @N]>> attributes {function.allow_witness} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %self = struct.new : !struct.type<@AssertArrsEq<[@T, @N]>>
      %0 = function.call @Zip::@compute(%arg0, %arg1) : (!array.type<@N x !poly.tvar<@T>>, !array.type<@N x !poly.tvar<@T>>) -> !struct.type<@Zip<[!poly.tvar<@T>, !poly.tvar<@T>, @N]>>
      struct.writef %self[@"$temp"] = %0 : <@AssertArrsEq<[@T, @N]>>, !struct.type<@Zip<[!poly.tvar<@T>, !poly.tvar<@T>, @N]>>
      %1 = struct.readf %self[@"$temp"] : <@AssertArrsEq<[@T, @N]>>, !struct.type<@Zip<[!poly.tvar<@T>, !poly.tvar<@T>, @N]>>
      %2 = struct.readf %1[@"$super"] : <@Zip<[!poly.tvar<@T>, !poly.tvar<@T>, @N]>>, !array.type<#map x !struct.type<@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>>
      %3 = poly.read_const @N : index
      %missing1 = array.new{()[%3]} : !array.type<#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>
      struct.writef %self[@"$temp_0"] = %missing1 : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>
      %missing2 = array.new{()[%3]} : !array.type<#map x !struct.type<@Component<[]>>>
      struct.writef %self[@"$temp_1"] = %missing2 : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
      %array = array.new{()[%3]} : <#map x !struct.type<@Component<[]>>>
      %4 = array.len %2, %c0 : <#map x !struct.type<@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>>
      scf.for %arg2 = %c0 to %4 step %c1 {
        %6 = array.read %2[%arg2] : <#map x !struct.type<@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>>, !struct.type<@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>
        %7 = struct.readf %6[@fst] : <@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>, !poly.tvar<@T>
        %8 = struct.readf %6[@snd] : <@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>, !poly.tvar<@T>
        %9 = function.call @EnsureEq::@compute(%7, %8) : (!poly.tvar<@T>, !poly.tvar<@T>) -> !struct.type<@EnsureEq<[!poly.tvar<@T>]>>
        %10 = struct.readf %self[@"$temp_0"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>
        array.write %10[%arg2] = %9 : <#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>, !struct.type<@EnsureEq<[!poly.tvar<@T>]>>
        struct.writef %self[@"$temp_0"] = %10 : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>
        %11 = struct.readf %self[@"$temp_0"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>
        %12 = array.read %11[%arg2] : <#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>, !struct.type<@EnsureEq<[!poly.tvar<@T>]>>
        %13 = function.call @Component::@compute() : () -> !struct.type<@Component<[]>>
        %14 = struct.readf %self[@"$temp_1"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
        array.write %14[%arg2] = %13 : <#map x !struct.type<@Component<[]>>>, !struct.type<@Component<[]>>
        struct.writef %self[@"$temp_1"] = %14 : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
        %15 = struct.readf %self[@"$temp_1"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
        %16 = array.read %15[%arg2] : <#map x !struct.type<@Component<[]>>>, !struct.type<@Component<[]>>
        array.write %array[%arg2] = %16 : <#map x !struct.type<@Component<[]>>>, !struct.type<@Component<[]>>
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
      %5 = struct.readf %self[@"$array"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
      struct.writef %self[@"$super"] = %5 : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
      function.return %self : !struct.type<@AssertArrsEq<[@T, @N]>>
    }
    function.def @constrain(%arg0: !struct.type<@AssertArrsEq<[@T, @N]>>, %arg1: !array.type<@N x !poly.tvar<@T>>, %arg2: !array.type<@N x !poly.tvar<@T>>) attributes {function.allow_constraint} {
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %0 = struct.readf %arg0[@"$temp"] : <@AssertArrsEq<[@T, @N]>>, !struct.type<@Zip<[!poly.tvar<@T>, !poly.tvar<@T>, @N]>>
      function.call @Zip::@constrain(%0, %arg1, %arg2) : (!struct.type<@Zip<[!poly.tvar<@T>, !poly.tvar<@T>, @N]>>, !array.type<@N x !poly.tvar<@T>>, !array.type<@N x !poly.tvar<@T>>) -> ()
      %1 = struct.readf %0[@"$super"] : <@Zip<[!poly.tvar<@T>, !poly.tvar<@T>, @N]>>, !array.type<#map x !struct.type<@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>>
      %2 = poly.read_const @N : index
      %array = array.new{()[%2]} : <#map x !struct.type<@Component<[]>>>
      %3 = array.len %1, %c0 : <#map x !struct.type<@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>>
      scf.for %arg3 = %c0 to %3 step %c1 {
        %5 = array.read %1[%arg3] : <#map x !struct.type<@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>>, !struct.type<@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>
        %6 = struct.readf %5[@fst] : <@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>, !poly.tvar<@T>
        %7 = struct.readf %5[@snd] : <@Pair<[!poly.tvar<@T>, !poly.tvar<@T>]>>, !poly.tvar<@T>
        %8 = struct.readf %arg0[@"$temp_0"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>
        %9 = struct.readf %arg0[@"$temp_0"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>
        %10 = array.read %9[%arg3] : <#map x !struct.type<@EnsureEq<[!poly.tvar<@T>]>>>, !struct.type<@EnsureEq<[!poly.tvar<@T>]>>
        function.call @EnsureEq::@constrain(%10, %6, %7) : (!struct.type<@EnsureEq<[!poly.tvar<@T>]>>, !poly.tvar<@T>, !poly.tvar<@T>) -> ()
        %11 = struct.readf %arg0[@"$temp_1"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
        %12 = struct.readf %arg0[@"$temp_1"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
        %13 = array.read %12[%arg3] : <#map x !struct.type<@Component<[]>>>, !struct.type<@Component<[]>>
        function.call @Component::@constrain(%13) : (!struct.type<@Component<[]>>) -> ()
        array.write %array[%arg3] = %13 : <#map x !struct.type<@Component<[]>>>, !struct.type<@Component<[]>>
      } {original_op = "map"}
      %4 = struct.readf %arg0[@"$array"] : <@AssertArrsEq<[@T, @N]>>, !array.type<#map x !struct.type<@Component<[]>>>
      function.return
    }
  }
  struct.def @MakeGuess<[@COLORS, @PEGS]> {
    struct.field @"$super" : !struct.type<@Guess<[]>>
    struct.field @"$temp_9" : !struct.type<@Guess<[]>> {column}
    struct.field @"$temp_8" : !struct.type<@Log<[]>>
    struct.field @partialGuesses : !felt.type
    struct.field @"$temp_7" : !array.type<#map x !felt.type>
    struct.field @"$temp_6" : !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
    struct.field @"$temp_5" : !array.type<#map x !struct.type<@Minimum<[]>>>
    struct.field @pegsCount : !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
    struct.field @guessCount : !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
    struct.field @"$array_0" : !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
    struct.field @"$temp_4" : !struct.type<@Log<[]>>
    struct.field @"$temp_3" : !array.type<#map x !felt.type>
    struct.field @"$temp_2" : !array.type<#map x !struct.type<@IsZero<[]>>> {column}
    struct.field @"$array" : !array.type<#map x !struct.type<@IsZero<[]>>> {column}
    struct.field @"$temp_1" : !struct.type<@Zip<[!felt.type, !felt.type, @PEGS]>>
    struct.field @"$temp_0" : !struct.type<@AssertArrsEq<[!felt.type, 24]>>
    struct.field @code : !struct.type<@SetCode<[@COLORS, @PEGS]>>
    struct.field @"$temp" : !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
    function.def @compute(%arg0: !struct.type<@Nonce<[]>>, %arg1: !struct.type<@Pegs<[@PEGS]>>, %arg2: !struct.type<@CodeHash<[]>>, %arg3: !struct.type<@Pegs<[@PEGS]>>) -> !struct.type<@MakeGuess<[@COLORS, @PEGS]>> attributes {function.allow_witness} {
      %0 = string.new "Partial guesses: %u"
      %1 = string.new "Correct guesses: %u"
      %felt_const_0 = felt.const 0
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %self = struct.new : !struct.type<@MakeGuess<[@COLORS, @PEGS]>>
      %2 = poly.read_const @COLORS : !felt.type
      %3 = function.call @CheckBounds::@compute(%arg3) : (!struct.type<@Pegs<[@PEGS]>>) -> !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
      struct.writef %self[@"$temp"] = %3 : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
      %4 = struct.readf %self[@"$temp"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
      %5 = function.call @SetCode::@compute(%arg0, %arg1) : (!struct.type<@Nonce<[]>>, !struct.type<@Pegs<[@PEGS]>>) -> !struct.type<@SetCode<[@COLORS, @PEGS]>>
      struct.writef %self[@code] = %5 : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@SetCode<[@COLORS, @PEGS]>>
      %6 = struct.readf %self[@code] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@SetCode<[@COLORS, @PEGS]>>
      %7 = struct.readf %arg2[@"$super"] : <@CodeHash<[]>>, !array.type<24 x !felt.type>
      %8 = struct.readf %6[@"$super"] : <@SetCode<[@COLORS, @PEGS]>>, !struct.type<@GenerateCodeHash<[@PEGS]>>
      %9 = struct.readf %8[@"$super"] : <@GenerateCodeHash<[@PEGS]>>, !struct.type<@CodeHash<[]>>
      %10 = struct.readf %9[@"$super"] : <@CodeHash<[]>>, !array.type<24 x !felt.type>
      %11 = function.call @AssertArrsEq::@compute(%7, %10) : (!array.type<24 x !felt.type>, !array.type<24 x !felt.type>) -> !struct.type<@AssertArrsEq<[!felt.type, 24]>>
      struct.writef %self[@"$temp_0"] = %11 : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@AssertArrsEq<[!felt.type, 24]>>
      %12 = struct.readf %self[@"$temp_0"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@AssertArrsEq<[!felt.type, 24]>>
      %13 = struct.readf %arg1[@"$super"] : <@Pegs<[@PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
      %array = array.new  : <@PEGS x !felt.type>
      %14 = array.len %13, %c0 : <@PEGS x !struct.type<@Reg<[]>>>
      scf.for %arg4 = %c0 to %c1 step %14 {
        %41 = array.read %13[%arg4] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %42 = struct.readf %41[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %43 = struct.readf %42[@"$super"] : <@NondetReg<[]>>, !felt.type
        array.write %array[%arg4] = %43 : <@PEGS x !felt.type>, !felt.type
      }
      %15 = struct.readf %arg3[@"$super"] : <@Pegs<[@PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
      %array_0 = array.new  : <@PEGS x !felt.type>
      %16 = array.len %15, %c0 : <@PEGS x !struct.type<@Reg<[]>>>
      scf.for %arg4 = %c0 to %c1 step %16 {
        %41 = array.read %15[%arg4] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %42 = struct.readf %41[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %43 = struct.readf %42[@"$super"] : <@NondetReg<[]>>, !felt.type
        array.write %array_0[%arg4] = %43 : <@PEGS x !felt.type>, !felt.type
      }
      %17 = function.call @Zip::@compute(%array, %array_0) : (!array.type<@PEGS x !felt.type>, !array.type<@PEGS x !felt.type>) -> !struct.type<@Zip<[!felt.type, !felt.type, @PEGS]>>
      struct.writef %self[@"$temp_1"] = %17 : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Zip<[!felt.type, !felt.type, @PEGS]>>
      %18 = struct.readf %self[@"$temp_1"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Zip<[!felt.type, !felt.type, @PEGS]>>
      %19 = struct.readf %18[@"$super"] : <@Zip<[!felt.type, !felt.type, @PEGS]>>, !array.type<#map x !struct.type<@Pair<[!felt.type, !felt.type]>>>
      %20 = poly.read_const @PEGS : index
      %array_1 = array.new{()[%20]} : <#map x !struct.type<@IsZero<[]>>>
      %21 = array.len %19, %c0 : <#map x !struct.type<@Pair<[!felt.type, !felt.type]>>>
      scf.for %arg4 = %c0 to %21 step %c1 {
        %41 = array.read %19[%arg4] : <#map x !struct.type<@Pair<[!felt.type, !felt.type]>>>, !struct.type<@Pair<[!felt.type, !felt.type]>>
        %42 = struct.readf %41[@fst] : <@Pair<[!felt.type, !felt.type]>>, !felt.type
        %43 = struct.readf %41[@snd] : <@Pair<[!felt.type, !felt.type]>>, !felt.type
        %44 = felt.sub %42, %43 : !felt.type, !felt.type
        %45 = function.call @IsZero::@compute(%44) : (!felt.type) -> !struct.type<@IsZero<[]>>
        %46 = struct.readf %self[@"$temp_2"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@IsZero<[]>>>
        array.write %46[%arg4] = %45 : <#map x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        struct.writef %self[@"$temp_2"] = %46 : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@IsZero<[]>>>
        %47 = struct.readf %self[@"$temp_2"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@IsZero<[]>>>
        %48 = array.read %47[%arg4] : <#map x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        array.write %array_1[%arg4] = %48 : <#map x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
      } {original_op = "map"}
      struct.writef %self[@"$array"] = %array_1 : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@IsZero<[]>>>
      %22 = struct.readf %self[@"$array"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@IsZero<[]>>>
      %23 = array.len %22, %c0 : <#map x !struct.type<@IsZero<[]>>>
      %24 = scf.for %arg4 = %c0 to %23 step %c1 iter_args(%arg5 = %felt_const_0) -> (!felt.type) {
        %41 = array.read %22[%arg4] : <#map x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        %42 = struct.readf %41[@"$super"] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
        %43 = struct.readf %42[@"$super"] : <@NondetReg<[]>>, !felt.type
        %44 = felt.add %arg5, %43 : !felt.type, !felt.type
        %45 = struct.readf %self[@"$temp_3"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        array.write %45[%arg4] = %44 : <#map x !felt.type>, !felt.type
        struct.writef %self[@"$temp_3"] = %45 : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        %46 = struct.readf %self[@"$temp_3"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        %47 = array.read %46[%arg4] : <#map x !felt.type>, !felt.type
        scf.yield %47 : !felt.type
      } {original_op = "reduce"}
      %array_2 = array.new %24 : <1 x !felt.type>
      %25 = poly.unifiable_cast %array_2 : (!array.type<1 x !felt.type>) -> !array.type<? x !felt.type>
      %26 = function.call @Log::@compute(%1, %25) : (!string.type, !array.type<? x !felt.type>) -> !struct.type<@Log<[]>>
      struct.writef %self[@"$temp_4"] = %26 : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Log<[]>>
      %27 = struct.readf %self[@"$temp_4"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Log<[]>>
      %28 = poly.read_const @COLORS : index
      %array_3 = array.new{()[%28]} : <#map x !felt.type>
      %29 = poly.read_const @COLORS : index
      scf.for %arg4 = %c0 to %29 step %c1 {
        %41 = cast.tofelt %arg4 : index
        array.write %array_3[%arg4] = %41 : <#map x !felt.type>, !felt.type
      }
      %30 = poly.read_const @COLORS : index
      %array_4 = array.new{()[%30]} : <#map x !struct.type<@block$_0<[@PEGS]>>>
      %31 = array.len %array_3, %c0 : <#map x !felt.type>
      scf.for %arg4 = %c0 to %31 step %c1 {
        %41 = array.read %array_3[%arg4] : <#map x !felt.type>, !felt.type
        %42 = function.call @CountColors::@compute(%arg3, %41) : (!struct.type<@Pegs<[@PEGS]>>, !felt.type) -> !struct.type<@CountColors<[@PEGS]>>
        %43 = struct.readf %self[@guessCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        array.write %43[%arg4] = %42 : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        struct.writef %self[@guessCount] = %43 : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %44 = struct.readf %self[@guessCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %45 = array.read %44[%arg4] : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        %46 = function.call @CountColors::@compute(%arg1, %41) : (!struct.type<@Pegs<[@PEGS]>>, !felt.type) -> !struct.type<@CountColors<[@PEGS]>>
        %47 = struct.readf %self[@pegsCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        array.write %47[%arg4] = %46 : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        struct.writef %self[@pegsCount] = %47 : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %48 = struct.readf %self[@pegsCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %49 = array.read %48[%arg4] : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        %50 = struct.readf %45[@"$super"] : <@CountColors<[@PEGS]>>, !felt.type
        %51 = struct.readf %49[@"$super"] : <@CountColors<[@PEGS]>>, !felt.type
        %52 = function.call @Minimum::@compute(%50, %51) : (!felt.type, !felt.type) -> !struct.type<@Minimum<[]>>
        %53 = struct.readf %self[@"$temp_5"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@Minimum<[]>>>
        array.write %53[%arg4] = %52 : <#map x !struct.type<@Minimum<[]>>>, !struct.type<@Minimum<[]>>
        struct.writef %self[@"$temp_5"] = %53 : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@Minimum<[]>>>
        %54 = struct.readf %self[@"$temp_5"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@Minimum<[]>>>
        %55 = array.read %54[%arg4] : <#map x !struct.type<@Minimum<[]>>>, !struct.type<@Minimum<[]>>
        %56 = struct.readf %self[@guessCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %57 = array.read %56[%arg4] : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        %58 = struct.readf %self[@pegsCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %59 = array.read %58[%arg4] : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        %60 = function.call @block$_0::@compute(%55, %57, %59) : (!struct.type<@Minimum<[]>>, !struct.type<@CountColors<[@PEGS]>>, !struct.type<@CountColors<[@PEGS]>>) -> !struct.type<@block$_0<[@PEGS]>>
        %61 = struct.readf %self[@"$temp_6"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
        array.write %61[%arg4] = %60 : <#map x !struct.type<@block$_0<[@PEGS]>>>, !struct.type<@block$_0<[@PEGS]>>
        struct.writef %self[@"$temp_6"] = %61 : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
        %62 = struct.readf %self[@"$temp_6"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
        %63 = array.read %62[%arg4] : <#map x !struct.type<@block$_0<[@PEGS]>>>, !struct.type<@block$_0<[@PEGS]>>
        array.write %array_4[%arg4] = %63 : <#map x !struct.type<@block$_0<[@PEGS]>>>, !struct.type<@block$_0<[@PEGS]>>
      } {original_op = "map"}
      struct.writef %self[@"$array_0"] = %array_4 : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
      %32 = struct.readf %self[@"$array_0"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
      %33 = array.len %32, %c0 : <#map x !struct.type<@block$_0<[@PEGS]>>>
      %34 = scf.for %arg4 = %c0 to %33 step %c1 iter_args(%arg5 = %felt_const_0) -> (!felt.type) {
        %41 = array.read %32[%arg4] : <#map x !struct.type<@block$_0<[@PEGS]>>>, !struct.type<@block$_0<[@PEGS]>>
        %42 = struct.readf %41[@"$super"] : <@block$_0<[@PEGS]>>, !struct.type<@Minimum<[]>>
        %43 = struct.readf %42[@"$super"] : <@Minimum<[]>>, !felt.type
        %44 = felt.add %arg5, %43 : !felt.type, !felt.type
        %45 = struct.readf %self[@"$temp_7"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        array.write %45[%arg4] = %44 : <#map x !felt.type>, !felt.type
        struct.writef %self[@"$temp_7"] = %45 : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        %46 = struct.readf %self[@"$temp_7"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        %47 = array.read %46[%arg4] : <#map x !felt.type>, !felt.type
        scf.yield %47 : !felt.type
      } {original_op = "reduce"}
      %35 = felt.sub %34, %24 : !felt.type, !felt.type
      struct.writef %self[@partialGuesses] = %35 : <@MakeGuess<[@COLORS, @PEGS]>>, !felt.type
      %array_5 = array.new %35 : <1 x !felt.type>
      %36 = poly.unifiable_cast %array_5 : (!array.type<1 x !felt.type>) -> !array.type<? x !felt.type>
      %37 = function.call @Log::@compute(%0, %36) : (!string.type, !array.type<? x !felt.type>) -> !struct.type<@Log<[]>>
      struct.writef %self[@"$temp_8"] = %37 : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Log<[]>>
      %38 = struct.readf %self[@"$temp_8"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Log<[]>>
      %39 = function.call @Guess::@compute(%24, %35) : (!felt.type, !felt.type) -> !struct.type<@Guess<[]>>
      struct.writef %self[@"$temp_9"] = %39 : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Guess<[]>>
      %40 = struct.readf %self[@"$temp_9"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Guess<[]>>
      struct.writef %self[@"$super"] = %40 : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Guess<[]>>
      function.return %self : !struct.type<@MakeGuess<[@COLORS, @PEGS]>>
    }
    function.def @constrain(%arg0: !struct.type<@MakeGuess<[@COLORS, @PEGS]>>, %arg1: !struct.type<@Nonce<[]>>, %arg2: !struct.type<@Pegs<[@PEGS]>>, %arg3: !struct.type<@CodeHash<[]>>, %arg4: !struct.type<@Pegs<[@PEGS]>>) attributes {function.allow_constraint} {
      %0 = string.new "Partial guesses: %u"
      %1 = string.new "Correct guesses: %u"
      %felt_const_0 = felt.const 0
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %2 = poly.read_const @COLORS : !felt.type
      %3 = struct.readf %arg0[@"$temp"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@CheckBounds<[@COLORS, @PEGS]>>
      function.call @CheckBounds::@constrain(%3, %arg4) : (!struct.type<@CheckBounds<[@COLORS, @PEGS]>>, !struct.type<@Pegs<[@PEGS]>>) -> ()
      %4 = struct.readf %arg0[@code] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@SetCode<[@COLORS, @PEGS]>>
      function.call @SetCode::@constrain(%4, %arg1, %arg2) : (!struct.type<@SetCode<[@COLORS, @PEGS]>>, !struct.type<@Nonce<[]>>, !struct.type<@Pegs<[@PEGS]>>) -> ()
      %5 = struct.readf %arg3[@"$super"] : <@CodeHash<[]>>, !array.type<24 x !felt.type>
      %6 = struct.readf %4[@"$super"] : <@SetCode<[@COLORS, @PEGS]>>, !struct.type<@GenerateCodeHash<[@PEGS]>>
      %7 = struct.readf %6[@"$super"] : <@GenerateCodeHash<[@PEGS]>>, !struct.type<@CodeHash<[]>>
      %8 = struct.readf %7[@"$super"] : <@CodeHash<[]>>, !array.type<24 x !felt.type>
      %9 = struct.readf %arg0[@"$temp_0"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@AssertArrsEq<[!felt.type, 24]>>
      function.call @AssertArrsEq::@constrain(%9, %5, %8) : (!struct.type<@AssertArrsEq<[!felt.type, 24]>>, !array.type<24 x !felt.type>, !array.type<24 x !felt.type>) -> ()
      %10 = struct.readf %arg2[@"$super"] : <@Pegs<[@PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
      %array = array.new  : <@PEGS x !felt.type>
      %11 = array.len %10, %c0 : <@PEGS x !struct.type<@Reg<[]>>>
      scf.for %arg5 = %c0 to %c1 step %11 {
        %34 = array.read %10[%arg5] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %35 = struct.readf %34[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %36 = struct.readf %35[@"$super"] : <@NondetReg<[]>>, !felt.type
        array.write %array[%arg5] = %36 : <@PEGS x !felt.type>, !felt.type
      }
      %12 = struct.readf %arg4[@"$super"] : <@Pegs<[@PEGS]>>, !array.type<@PEGS x !struct.type<@Reg<[]>>>
      %array_0 = array.new  : <@PEGS x !felt.type>
      %13 = array.len %12, %c0 : <@PEGS x !struct.type<@Reg<[]>>>
      scf.for %arg5 = %c0 to %c1 step %13 {
        %34 = array.read %12[%arg5] : <@PEGS x !struct.type<@Reg<[]>>>, !struct.type<@Reg<[]>>
        %35 = struct.readf %34[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
        %36 = struct.readf %35[@"$super"] : <@NondetReg<[]>>, !felt.type
        array.write %array_0[%arg5] = %36 : <@PEGS x !felt.type>, !felt.type
      }
      %14 = struct.readf %arg0[@"$temp_1"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Zip<[!felt.type, !felt.type, @PEGS]>>
      function.call @Zip::@constrain(%14, %array, %array_0) : (!struct.type<@Zip<[!felt.type, !felt.type, @PEGS]>>, !array.type<@PEGS x !felt.type>, !array.type<@PEGS x !felt.type>) -> ()
      %15 = struct.readf %14[@"$super"] : <@Zip<[!felt.type, !felt.type, @PEGS]>>, !array.type<#map x !struct.type<@Pair<[!felt.type, !felt.type]>>>
      %16 = poly.read_const @PEGS : index
      %array_1 = array.new{()[%16]} : <#map x !struct.type<@IsZero<[]>>>
      %17 = array.len %15, %c0 : <#map x !struct.type<@Pair<[!felt.type, !felt.type]>>>
      scf.for %arg5 = %c0 to %17 step %c1 {
        %34 = array.read %15[%arg5] : <#map x !struct.type<@Pair<[!felt.type, !felt.type]>>>, !struct.type<@Pair<[!felt.type, !felt.type]>>
        %35 = struct.readf %34[@fst] : <@Pair<[!felt.type, !felt.type]>>, !felt.type
        %36 = struct.readf %34[@snd] : <@Pair<[!felt.type, !felt.type]>>, !felt.type
        %37 = felt.sub %35, %36 : !felt.type, !felt.type
        %38 = struct.readf %arg0[@"$temp_2"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@IsZero<[]>>>
        %39 = struct.readf %arg0[@"$temp_2"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@IsZero<[]>>>
        %40 = array.read %39[%arg5] : <#map x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        function.call @IsZero::@constrain(%40, %37) : (!struct.type<@IsZero<[]>>, !felt.type) -> ()
        array.write %array_1[%arg5] = %40 : <#map x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
      } {original_op = "map"}
      %18 = struct.readf %arg0[@"$array"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@IsZero<[]>>>
      %19 = array.len %18, %c0 : <#map x !struct.type<@IsZero<[]>>>
      %20 = scf.for %arg5 = %c0 to %19 step %c1 iter_args(%arg6 = %felt_const_0) -> (!felt.type) {
        %34 = array.read %18[%arg5] : <#map x !struct.type<@IsZero<[]>>>, !struct.type<@IsZero<[]>>
        %35 = struct.readf %34[@"$super"] : <@IsZero<[]>>, !struct.type<@NondetReg<[]>>
        %36 = struct.readf %35[@"$super"] : <@NondetReg<[]>>, !felt.type
        %37 = struct.readf %arg0[@"$temp_3"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        %38 = struct.readf %arg0[@"$temp_3"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        %39 = array.read %38[%arg5] : <#map x !felt.type>, !felt.type
        scf.yield %39 : !felt.type
      } {original_op = "reduce"}
      %array_2 = array.new %20 : <1 x !felt.type>
      %21 = poly.unifiable_cast %array_2 : (!array.type<1 x !felt.type>) -> !array.type<? x !felt.type>
      %22 = struct.readf %arg0[@"$temp_4"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Log<[]>>
      function.call @Log::@constrain(%22, %1, %21) : (!struct.type<@Log<[]>>, !string.type, !array.type<? x !felt.type>) -> ()
      %23 = poly.read_const @COLORS : index
      %array_3 = array.new{()[%23]} : <#map x !felt.type>
      %24 = poly.read_const @COLORS : index
      scf.for %arg5 = %c0 to %24 step %c1 {
        %34 = cast.tofelt %arg5 : index
        array.write %array_3[%arg5] = %34 : <#map x !felt.type>, !felt.type
      }
      %25 = poly.read_const @COLORS : index
      %array_4 = array.new{()[%25]} : <#map x !struct.type<@block$_0<[@PEGS]>>>
      %26 = array.len %array_3, %c0 : <#map x !felt.type>
      scf.for %arg5 = %c0 to %26 step %c1 {
        %34 = array.read %array_3[%arg5] : <#map x !felt.type>, !felt.type
        %35 = struct.readf %arg0[@guessCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %36 = struct.readf %arg0[@guessCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %37 = array.read %36[%arg5] : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        function.call @CountColors::@constrain(%37, %arg4, %34) : (!struct.type<@CountColors<[@PEGS]>>, !struct.type<@Pegs<[@PEGS]>>, !felt.type) -> ()
        %38 = struct.readf %arg0[@pegsCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %39 = struct.readf %arg0[@pegsCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %40 = array.read %39[%arg5] : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        function.call @CountColors::@constrain(%40, %arg2, %34) : (!struct.type<@CountColors<[@PEGS]>>, !struct.type<@Pegs<[@PEGS]>>, !felt.type) -> ()
        %41 = struct.readf %37[@"$super"] : <@CountColors<[@PEGS]>>, !felt.type
        %42 = struct.readf %40[@"$super"] : <@CountColors<[@PEGS]>>, !felt.type
        %43 = struct.readf %arg0[@"$temp_5"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@Minimum<[]>>>
        %44 = struct.readf %arg0[@"$temp_5"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@Minimum<[]>>>
        %45 = array.read %44[%arg5] : <#map x !struct.type<@Minimum<[]>>>, !struct.type<@Minimum<[]>>
        function.call @Minimum::@constrain(%45, %41, %42) : (!struct.type<@Minimum<[]>>, !felt.type, !felt.type) -> ()
        %46 = struct.readf %arg0[@guessCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %47 = array.read %46[%arg5] : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        %48 = struct.readf %arg0[@pegsCount] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@CountColors<[@PEGS]>>>
        %49 = array.read %48[%arg5] : <#map x !struct.type<@CountColors<[@PEGS]>>>, !struct.type<@CountColors<[@PEGS]>>
        %50 = struct.readf %arg0[@"$temp_6"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
        %51 = struct.readf %arg0[@"$temp_6"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
        %52 = array.read %51[%arg5] : <#map x !struct.type<@block$_0<[@PEGS]>>>, !struct.type<@block$_0<[@PEGS]>>
        function.call @block$_0::@constrain(%52, %45, %47, %49) : (!struct.type<@block$_0<[@PEGS]>>, !struct.type<@Minimum<[]>>, !struct.type<@CountColors<[@PEGS]>>, !struct.type<@CountColors<[@PEGS]>>) -> ()
        array.write %array_4[%arg5] = %52 : <#map x !struct.type<@block$_0<[@PEGS]>>>, !struct.type<@block$_0<[@PEGS]>>
      } {original_op = "map"}
      %27 = struct.readf %arg0[@"$array_0"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !struct.type<@block$_0<[@PEGS]>>>
      %28 = array.len %27, %c0 : <#map x !struct.type<@block$_0<[@PEGS]>>>
      %29 = scf.for %arg5 = %c0 to %28 step %c1 iter_args(%arg6 = %felt_const_0) -> (!felt.type) {
        %34 = array.read %27[%arg5] : <#map x !struct.type<@block$_0<[@PEGS]>>>, !struct.type<@block$_0<[@PEGS]>>
        %35 = struct.readf %34[@"$super"] : <@block$_0<[@PEGS]>>, !struct.type<@Minimum<[]>>
        %36 = struct.readf %35[@"$super"] : <@Minimum<[]>>, !felt.type
        %37 = struct.readf %arg0[@"$temp_7"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        %38 = struct.readf %arg0[@"$temp_7"] : <@MakeGuess<[@COLORS, @PEGS]>>, !array.type<#map x !felt.type>
        %39 = array.read %38[%arg5] : <#map x !felt.type>, !felt.type
        scf.yield %39 : !felt.type
      } {original_op = "reduce"}
      %30 = felt.sub %29, %20 : !felt.type, !felt.type
      %array_5 = array.new %30 : <1 x !felt.type>
      %31 = poly.unifiable_cast %array_5 : (!array.type<1 x !felt.type>) -> !array.type<? x !felt.type>
      %32 = struct.readf %arg0[@"$temp_8"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Log<[]>>
      function.call @Log::@constrain(%32, %0, %31) : (!struct.type<@Log<[]>>, !string.type, !array.type<? x !felt.type>) -> ()
      %33 = struct.readf %arg0[@"$temp_9"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Guess<[]>>
      function.call @Guess::@constrain(%33, %20, %30) : (!struct.type<@Guess<[]>>, !felt.type, !felt.type) -> ()
      function.return
    }
  }
  struct.def @MakeGuessWithChecks<[@COLORS, @PEGS]> {
    struct.field @"$super" : !struct.type<@MakeGuess<[@COLORS, @PEGS]>>
    struct.field @"$temp" : !struct.type<@Assert<[]>>
    struct.field @guess : !struct.type<@MakeGuess<[@COLORS, @PEGS]>> {column}
    function.def @compute(%arg0: !struct.type<@Nonce<[]>>, %arg1: !struct.type<@Pegs<[@PEGS]>>, %arg2: !struct.type<@CodeHash<[]>>, %arg3: !struct.type<@Pegs<[@PEGS]>>) -> !struct.type<@MakeGuessWithChecks<[@COLORS, @PEGS]>> attributes {function.allow_witness} {
      %0 = string.new "Guess check post condition failed"
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %self = struct.new : !struct.type<@MakeGuessWithChecks<[@COLORS, @PEGS]>>
      %1 = poly.read_const @PEGS : !felt.type
      %2 = function.call @MakeGuess::@compute(%arg0, %arg1, %arg2, %arg3) : (!struct.type<@Nonce<[]>>, !struct.type<@Pegs<[@PEGS]>>, !struct.type<@CodeHash<[]>>, !struct.type<@Pegs<[@PEGS]>>) -> !struct.type<@MakeGuess<[@COLORS, @PEGS]>>
      struct.writef %self[@guess] = %2 : <@MakeGuessWithChecks<[@COLORS, @PEGS]>>, !struct.type<@MakeGuess<[@COLORS, @PEGS]>>
      %3 = struct.readf %self[@guess] : <@MakeGuessWithChecks<[@COLORS, @PEGS]>>, !struct.type<@MakeGuess<[@COLORS, @PEGS]>>
      %4 = struct.readf %3[@"$super"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Guess<[]>>
      %5 = struct.readf %4[@correct] : <@Guess<[]>>, !struct.type<@Reg<[]>>
      %6 = struct.readf %3[@"$super"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Guess<[]>>
      %7 = struct.readf %6[@partial] : <@Guess<[]>>, !struct.type<@Reg<[]>>
      %8 = struct.readf %5[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %9 = struct.readf %8[@"$super"] : <@NondetReg<[]>>, !felt.type
      %10 = struct.readf %7[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %11 = struct.readf %10[@"$super"] : <@NondetReg<[]>>, !felt.type
      %12 = felt.add %9, %11 : !felt.type, !felt.type
      %13 = felt.add %1, %felt_const_1 : !felt.type, !felt.type
      %14 = bool.cmp le(%felt_const_0, %12)
      %15 = bool.cmp lt(%12, %13)
      %16 = cast.tofelt %14 : i1
      %17 = cast.tofelt %15 : i1
      %18 = felt.mul %16, %17 : !felt.type, !felt.type
      %19 = bool.cmp eq(%18, %felt_const_0)
      %20 = cast.tofelt %19 : i1
      %21 = function.call @Assert::@compute(%20, %0) : (!felt.type, !string.type) -> !struct.type<@Assert<[]>>
      struct.writef %self[@"$temp"] = %21 : <@MakeGuessWithChecks<[@COLORS, @PEGS]>>, !struct.type<@Assert<[]>>
      %22 = struct.readf %self[@"$temp"] : <@MakeGuessWithChecks<[@COLORS, @PEGS]>>, !struct.type<@Assert<[]>>
      struct.writef %self[@"$super"] = %3 : <@MakeGuessWithChecks<[@COLORS, @PEGS]>>, !struct.type<@MakeGuess<[@COLORS, @PEGS]>>
      function.return %self : !struct.type<@MakeGuessWithChecks<[@COLORS, @PEGS]>>
    }
    function.def @constrain(%arg0: !struct.type<@MakeGuessWithChecks<[@COLORS, @PEGS]>>, %arg1: !struct.type<@Nonce<[]>>, %arg2: !struct.type<@Pegs<[@PEGS]>>, %arg3: !struct.type<@CodeHash<[]>>, %arg4: !struct.type<@Pegs<[@PEGS]>>) attributes {function.allow_constraint} {
      %0 = string.new "Guess check post condition failed"
      %felt_const_1 = felt.const 1
      %felt_const_0 = felt.const 0
      %1 = poly.read_const @PEGS : !felt.type
      %2 = struct.readf %arg0[@guess] : <@MakeGuessWithChecks<[@COLORS, @PEGS]>>, !struct.type<@MakeGuess<[@COLORS, @PEGS]>>
      function.call @MakeGuess::@constrain(%2, %arg1, %arg2, %arg3, %arg4) : (!struct.type<@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Nonce<[]>>, !struct.type<@Pegs<[@PEGS]>>, !struct.type<@CodeHash<[]>>, !struct.type<@Pegs<[@PEGS]>>) -> ()
      %3 = struct.readf %2[@"$super"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Guess<[]>>
      %4 = struct.readf %3[@correct] : <@Guess<[]>>, !struct.type<@Reg<[]>>
      %5 = struct.readf %2[@"$super"] : <@MakeGuess<[@COLORS, @PEGS]>>, !struct.type<@Guess<[]>>
      %6 = struct.readf %5[@partial] : <@Guess<[]>>, !struct.type<@Reg<[]>>
      %7 = struct.readf %4[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %8 = struct.readf %7[@"$super"] : <@NondetReg<[]>>, !felt.type
      %9 = struct.readf %6[@"$super"] : <@Reg<[]>>, !struct.type<@NondetReg<[]>>
      %10 = struct.readf %9[@"$super"] : <@NondetReg<[]>>, !felt.type
      %11 = felt.add %8, %10 : !felt.type, !felt.type
      %12 = felt.add %1, %felt_const_1 : !felt.type, !felt.type
      %13 = bool.cmp le(%felt_const_0, %11)
      %14 = bool.cmp lt(%11, %12)
      %15 = cast.tofelt %13 : i1
      %16 = cast.tofelt %14 : i1
      %17 = felt.mul %15, %16 : !felt.type, !felt.type
      %18 = bool.cmp eq(%17, %felt_const_0)
      %19 = cast.tofelt %18 : i1
      %20 = struct.readf %arg0[@"$temp"] : <@MakeGuessWithChecks<[@COLORS, @PEGS]>>, !struct.type<@Assert<[]>>
      function.call @Assert::@constrain(%20, %19, %0) : (!struct.type<@Assert<[]>>, !felt.type, !string.type) -> ()
      function.return
    }
  }
  struct.def @block$<[]> {
    struct.field @"$super" : !felt.type
    struct.field @g : !felt.type
    struct.field @j : !struct.type<@BitAnd<[]>>
    function.def @compute(%arg0: !felt.type, %arg1: !felt.type, %arg2: !struct.type<@BitAnd<[]>>) -> !struct.type<@block$<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@block$<[]>>
      struct.writef %self[@"$super"] = %arg0 : <@block$<[]>>, !felt.type
      struct.writef %self[@g] = %arg1 : <@block$<[]>>, !felt.type
      struct.writef %self[@j] = %arg2 : <@block$<[]>>, !struct.type<@BitAnd<[]>>
      function.return %self : !struct.type<@block$<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@block$<[]>>, %arg1: !felt.type, %arg2: !felt.type, %arg3: !struct.type<@BitAnd<[]>>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @block$_0<[@PEGS]> {
    struct.field @"$super" : !struct.type<@Minimum<[]>>
    struct.field @guessCount : !struct.type<@CountColors<[@PEGS]>>
    struct.field @pegsCount : !struct.type<@CountColors<[@PEGS]>>
    function.def @compute(%arg0: !struct.type<@Minimum<[]>>, %arg1: !struct.type<@CountColors<[@PEGS]>>, %arg2: !struct.type<@CountColors<[@PEGS]>>) -> !struct.type<@block$_0<[@PEGS]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@block$_0<[@PEGS]>>
      struct.writef %self[@"$super"] = %arg0 : <@block$_0<[@PEGS]>>, !struct.type<@Minimum<[]>>
      struct.writef %self[@guessCount] = %arg1 : <@block$_0<[@PEGS]>>, !struct.type<@CountColors<[@PEGS]>>
      struct.writef %self[@pegsCount] = %arg2 : <@block$_0<[@PEGS]>>, !struct.type<@CountColors<[@PEGS]>>
      function.return %self : !struct.type<@block$_0<[@PEGS]>>
    }
    function.def @constrain(%arg0: !struct.type<@block$_0<[@PEGS]>>, %arg1: !struct.type<@Minimum<[]>>, %arg2: !struct.type<@CountColors<[@PEGS]>>, %arg3: !struct.type<@CountColors<[@PEGS]>>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @block$_1<[]> {
    struct.field @"$super" : !struct.type<@Component<[]>>
    struct.field @check : !struct.type<@Reg<[]>> {column}
    function.def @compute(%arg0: !struct.type<@Component<[]>>, %arg1: !struct.type<@Reg<[]>>) -> !struct.type<@block$_1<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@block$_1<[]>>
      struct.writef %self[@"$super"] = %arg0 : <@block$_1<[]>>, !struct.type<@Component<[]>>
      struct.writef %self[@check] = %arg1 : <@block$_1<[]>>, !struct.type<@Reg<[]>>
      function.return %self : !struct.type<@block$_1<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@block$_1<[]>>, %arg1: !struct.type<@Component<[]>>, %arg2: !struct.type<@Reg<[]>>) attributes {function.allow_constraint} {
      function.return
    }
  }
  struct.def @block$_2<[]> {
    struct.field @"$super" : !struct.type<@MultiplyByCirculant<[]>>
    struct.field @chunk : !array.type<4 x !felt.type>
    function.def @compute(%arg0: !struct.type<@MultiplyByCirculant<[]>>, %arg1: !array.type<4 x !felt.type>) -> !struct.type<@block$_2<[]>> attributes {function.allow_witness} {
      %self = struct.new : !struct.type<@block$_2<[]>>
      struct.writef %self[@"$super"] = %arg0 : <@block$_2<[]>>, !struct.type<@MultiplyByCirculant<[]>>
      struct.writef %self[@chunk] = %arg1 : <@block$_2<[]>>, !array.type<4 x !felt.type>
      function.return %self : !struct.type<@block$_2<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@block$_2<[]>>, %arg1: !struct.type<@MultiplyByCirculant<[]>>, %arg2: !array.type<4 x !felt.type>) attributes {function.allow_constraint} {
      function.return
    }
  }
}
